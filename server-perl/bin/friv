#!/usr/bin/perl

############################################################################
# LICENSE INFORMATION - PLEASE READ
############################################################################
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
############################################################################

=begin TODO

* Fix history browsing so that the cursor snaps back to the end when ya done.

=end TODO

=cut

use warnings;
use strict;

use POE;
use POE::Wheel::ReadLine;
sub ARGS() { ARG0..$#_ }
sub POE() { @_[0..(ARG0-1)] }
use JavaScript::SpiderMonkey;
use Data::JavaScript::Anon;
use Getopt::Std;
use YAML;
use LWP;
use File::Spec;
use Archive::Zip::MemberRead;
use Tie::ExecHash;

my %opts;
getopts( 'u:h:p:r:o:f:b:c:l:d', \%opts );
# u == username
# h == host
# p == password
# r == resource (friv)
# o == port (5222)
# f == friv dir
# b == bookkeeper (bookkeeper@volity.net/volity)
# c == command to run on start
# d == daemonize
# l == logger configuration file (no logging, if undefined)

################
# GLOBALS
################
my $next_rpc_request_id = 0;
my $last_message_recipient;
my $working_dir  = $opts{'f'} || File::Spec->catdir( $ENV{HOME}, ".friv" );
my $command_list = File::Spec->catdir( $working_dir, "client.yaml" );
our @cmd_hist    = eval { @{ YAML::LoadFile($command_list) } };
my $ui_dir       = File::Spec->catdir( $working_dir, "ui" );

# Make sure the working dir exists and is usable.
unless (-e $working_dir) {
    foreach ($working_dir, $ui_dir) {
	mkdir $_ or die "Tried to create working directory $_ but failed: $!";
    }
}

# Set up the logger, if a config file has been provided.
if (defined($opts{l})) {
    my $logger_config_filename = $opts{l};
    Log::Log4perl::init_and_watch($logger_config_filename, 5);
    my $logger = Log::Log4perl->get_logger("Volity");
}


# Crank up the POE session that will manage our Jabber connection.
POE::Session->create(
    inline_states => {
        _start     => \&start,
        user_input => \&user_input,
        }
    );

POE::Kernel->run;


sub start {
    my( $session, $heap ) = @_[ SESSION, HEAP ];
    $heap->{'user'} = POE::Wheel::ReadLine->new(
        InputEvent => 'user_input',
        PutMode    => 'immediate',
        );
    foreach (@cmd_hist) {
        $heap->{'user'}->addhistory($_);
    }
    $heap->{'user'}->get( 'Volity> ' );
    my %env;
    tie( %env, 'Tie::ExecHash' );
    $heap->{'env'} = \%env;
    $heap->{'env'}{'connections'} = [
        sub {},                                            # SET
        sub { join ':', sort keys %{ $heap->{players} } }, # GET
        ];
    my @poe = &POE;
    $heap->{'env'}{'current_connection'} = [
        sub { cmd_use( @poe, $_[0] ) },
        sub {
            $heap->{'default_player'} ? 
              $heap->{'default_player'}->jid :
              ''
            },
        ];
    $heap->{'env'}{'username'}   = $opts{'u'};
    $heap->{'env'}{'resource'}   = $opts{'r'} || 'friv';
    $heap->{'env'}{'port'}       = $opts{'o'} || 5222;
    $heap->{'env'}{'host'}       = $opts{'h'};
    $heap->{'env'}{'bookkeeper'} = $opts{'b'} || 'bookkeeper@volity.net/volity';

    if ( $heap->{'env'}{'username'} and $heap->{'env'}{'host'} ) {
        act_connect( &POE, undef, $opts{'p'} );
    }

    if ( $opts{'c'} ) {
        run_command( &POE, $opts{c} );
    }
}

sub is_jid {
    my( $jid ) = @_;
    if ( $jid =~ /^[\w-]+@[\w-]+(?:\.[\w-]+)*(?:\/[\w-]+)?/ ) {
        return $jid;
    } else {
        return;
    }
}

sub check_jid {
    my( $heap, $jid ) = @_;
    if ( is_jid( $jid ) ) {
        return $jid;
    } else {
        output( $heap, "The string '$jid' doesn't look like a JabberID to me!" );
        output( $heap, "Command ignored." );
        return;
    }
}

END {
    YAML::DumpFile( $command_list, \@cmd_hist );
}

######################
# Input hanlding
######################

sub run_command {
    my( $heap, $line ) = @_[ HEAP, &ARGS ];
    my( $cmd, @args ) = tokenize( $line, $heap->{'env'} );
    $cmd = lc( $cmd );
    $cmd =~ s{\.}{_}g;
    return -1 if (not defined $cmd or $cmd eq '');
    if ( my $sub = __PACKAGE__->can( "cmd_$cmd" ) ) {
        &$sub( &POE, @args );
        return 1;
    }
    if ( $heap->{'commands'} ) {
       foreach (@{ $heap->{'commands'} }) {
           if ( $$_[0] eq $cmd ) {
               js_call( $heap->{'default_player'}->js, "client.$cmd", @args );
               return 1;
           }
       }
    }
    return 0;
}

sub user_input {
    my( $heap, $input, $exception ) = @_[ HEAP, &ARGS ];
    if ( defined $input ) {
        $heap->{'user'}->get('Volity> ');
        my $result = run_command( &POE, $input );
        if ( $result ) {
            return if $result == -1;
            $heap->{'user'}->addhistory( $input );
            push( @cmd_hist, $input );
        } else {
            output( $heap, "Unknown command: $input" );
        }
    } else {
        output( $heap, "Exception: $exception" );
        exit;
    }
}

sub js_call {
    my( $js, $cmd, @args ) = @_;
    my $script = "$cmd(";
    foreach ( @args ) {
        next if /^-?\d*(?:\.\d+)?$/;
	next if ref($_);
        s/'/\\'/g;
        $_ = "'$_'";
    }
    # Convert the @args into a list of JS-safe strings.
    my @js_args;
    for my $arg (@args) {
	if ( ref $arg ) {
	    push( @js_args, Data::JavaScript::Anon->anon_dump($arg) );
	} else {
	    push( @js_args, $arg );
	}
    }
    $script .= join ', ', @js_args;
    $script .= ")";
    {
	local $SIG{__WARN__} = sub {};
	return $js->eval( $script );
    }

}

sub tokenize {
    my( $str, $vars ) = @_;
    my @tokens;
    my $tok_count = 0;
    my $last = 0;
    my $re = qr{\G(?:
        "([^"]+)(?<!\\)" | #1 Double quoted segment
        '([^']+)(?<!\\)' | #2 Single quoted segment
        (                  #3 Unquoted segment
          (?:               # one or more subsegments
            [^\s"']   |      # non-space/quote char
            (?<=\\)'  |      # escaped single quote
            (?<=\\)"  |      # escaped double quote
            (?<=\\)\s        # escaped double quote
          )+
        ) |
        ((?:(?<!\\)\s)+)   #4 One or more unescaped spaces
        )}x;
        #" quote is here to fix stupid joe syntax highlighter bug
    while ( $str =~ /$re/g ) {
        $last = pos( $str );
        my( $dq, $sq, $nq, $sp ) = ( $1, $2, $3, $4 );
        my $val = $dq || $sq || $nq || $sp;
        if ( $dq or $nq ) {
            $val = expand( $val, $vars );
        } else {
            $val = unescape( $val );
        }
        if ($sp) {
            $tok_count ++ if $#tokens == $tok_count;
        } else {
            $tokens[$tok_count] .= $val;
        }
    }
    if ($last < length($str)) {
        $tokens[$tok_count] .= substr( $str, $last );
    }
    return @tokens;
}

sub unescape {
    my( $str ) = @_;
    $str =~ s/\\(.)/$1/g;
    return $str;
}

sub expand {
    my( $str, $vars ) = @_;
    $str =~ s{
            (?:
            (?<!\\)\$(\w+) |
            \\(.)
            )
        }{
            if ($1) {
                if ( defined $$vars{$1} ) {
                    $$vars{$1};
                } else {
                    '';
                }
            } else {
                $2
            }
        }gxe;
    $str = unescape( $str );
    return $str;
}

sub find_player {
    my( $heap, $jid ) = @_;
    my $plist = $heap->{'players'};
    return $$plist{$jid} if exists $$plist{$jid};
    my @matches;
    foreach (keys %$plist) {
        if (/^\Q$jid\E/) {
            push @matches, $_;
        }
    }
    if (!@matches or @matches > 1) {
        return;
    }
    return $$plist{$matches[0]};
}

###########################
# User commands
###########################
sub output {
    my( $heap, @line ) = @_;
    $heap->{'user'}->put( join '', @line );
    return;
}

sub user_output {
    my( $self, $heap, @line ) = @_[ OBJECT, HEAP, &ARGS ];
    output( $heap, @line );
}

sub act_connect {
    my( $heap, $jid, $password ) = @_[ HEAP, &ARGS ];
    my( $username, $host, $resource );
    if ( $jid ) {
        ($username,$host,$resource) = 
            ( $jid =~ m{^([^@]+)@([^/]+)(?:/(.+))?$} )
            or die "Couldn't match u\@h/r from $jid\n";
    } else {
        $username = $heap->{'env'}{'username'};
        $host     = $heap->{'env'}{'host'};
    }
    $resource ||= $heap->{'env'}{'resource'};
    my $user = Volity::User->new({
        host           => $host,
        password       => $password,
        resource       => $resource,
        port           => $heap->{'env'}{'port'},
        alias          => $resource,
        user           => $username,
        poe_heap       => $heap,
        bookkeeper_jid => $heap->{'env'}{'bookkeeper'},
        });
    $jid = $user->jid;
    $heap->{'players'}{$jid}  = $user;
    $heap->{'default_player'} = $user;

    my @args = &POE;
    $args[OBJECT] = undef;
    $user->output( sub { $args[OBJECT] = shift; user_output( @args, @_ ); } );
}

sub cmd_echo {
    my( $heap, @args ) = @_[ HEAP, &ARGS ];
    output( $heap, join ' ', @args );
}

sub cmd_set {
    my( $heap, $var_value ) = @_[ HEAP, &ARGS ];
    if ( $var_value ) {
        my( $var, $value ) = split /=/, $var_value, 2;
        $heap->{'env'}{$var} = $value;
    } else {
        foreach ( sort keys %{ $heap->{'env'} } ) {
            output( $heap, "$_=".$heap->{'env'}{$_} )
                if defined $heap->{'env'}{$_};
        }
    } 
}

sub cmd_env { cmd_set( &POE ) }

sub cmd_connect {
    my( $heap, $session, $jid, $password ) = @_[ HEAP, SESSION, &ARGS ];
    if ( !$jid and (!$heap->{username} or !$heap->{host}) ) {
        return output( $heap, "connect: Must specify JID" );
    }
    if ( !$password ) {
        return output( $heap, "connect: Must specify password" );
    }
    eval {
        act_connect( @_ );
    };
    if ($@) {
        return output( $heap, 'connect: '.$@ );
    }
}

sub act_disconnect {
    my( $heap, $jid ) = @_[ HEAP, &ARGS ];

    $jid ||= $heap->{'default_player'}->jid;

    die "Can't disconnect $jid: Not connected.\n"
        unless exists $heap->{'players'}{$jid};

    $heap->{'players'}{$jid}->send_presence( {type=>'unavailable'} );

    delete $heap->{'players'}{$jid};
    delete $heap->{'default_player'}
        if $heap->{'default_player'} and
           $heap->{'default_player'}->jid eq $jid;
}

sub cmd_disconnect {
    my( $heap, $session, $jid ) = @_[ HEAP, SESSION, &ARGS ];
    if ( !$jid and !$heap->{'default_player'} ) {
        return output( $heap, "disconnect: Must specify JID" );
        return;
    }
    $jid ||= $heap->{'default_player'}->jid;
    my $player;
    unless ( $player = find_player( $heap, $jid ) ) {
        return output( $heap, 
            "disconnect: Couldn't find single JID matching $jid."
            );
    }

    eval {
        act_disconnect( &POE,  );
    };
    if ($@) {
        return output( $heap, "disconect: $@" );
    }
}

sub cmd_source {
    my( $heap, $file ) = @_[ HEAP, &ARGS ];
    my $fh;
    open( $fh, $file )
        or open( $fh, File::Spec->catdir($working_dir, $file) )
        or return output($heap,"source: Could not open $file: $!");
    while ( <$fh> ) {
        my $result = run_command( &POE, $_ );
        unless ( $result ) {
            output( $heap, "source: Unknown command: $_" );
        }
    }
    close( $fh );
}

no strict 'refs';
BEGIN { *{'cmd__'} = \&cmd_source; }
use strict 'refs';

sub cmd_connections {
    my( $heap, $session ) = @_[ HEAP, SESSION, &ARGS ];
    foreach ( sort keys %{ $heap->{'players'} } ) {
        my $active = ($heap->{'default_player'}->jid eq $_)?'* ':'';
        output($heap,"${active}$_");
    }
}

sub cmd_use {
    my( $heap, $session, $jid ) = @_[ HEAP, SESSION, &ARGS ];
    if ( !$jid ) {
        return output( $heap, "use: Must specify JID" );
    }
    my $player;
    unless ( $player = find_player( $heap, $jid ) ) {
        return output( $heap, "use: Couldn't find single JID matching $jid." );
    }
    $heap->{'default_player'} = $player;
}

sub cmd_info {
    my( $heap ) = $_[ HEAP ];
    no warnings 'uninitialized';
    my $user = $heap->{'default_player'};
    output( $heap, $_ ) for
        "Status information:",
        "  JID        : ".$user->jid,
        "  Nickname   : ".$user->nick,
        "  Table JID  : ".$user->table_jid,
        "  Referee JID: ".$user->referee_jid;
}

sub cmd_quit {
    my( $heap ) = $_[ HEAP ];
    output( $heap, 'Be seeing you.' );
    foreach (keys %{ $heap->{'players'} }) {
    	act_disconnect( &POE, $_ );
    }
    exit;
}

sub cmd_invite {
    my( $heap, $invited ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ( $user->referee_jid ) {
        return output( $heap, "Create or join a table first!" );
    }
    unless ( $invited ) {
        return output( $heap, "Usage: invite [jid]" );
    }
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        to         => $user->referee_jid,
        id         => $rpc_id,
        methodname => 'volity.invite_player',
        args       => [$invited],
        handler    => 'invite_player',
        });

}

sub cmd_accept {
    my( $heap ) = $_[ HEAP ];
    my $user = $heap->{'default_player'};
    if ( my $invitation = $user->invitation ) {
        $user->current_command( 'accept_invitation' );
        $user->discover_uis_for_ruleset( $$invitation{ruleset} );
    }
}

sub cmd_nick {
    my( $heap, $nickname ) = @_[ HEAP, &ARGS ];
    unless ( $nickname ) {
        return output( $heap, "Form: nick <nickname>" );
    }
    $heap->{'default_player'}->nick( $nickname );
    output( $heap, "Nickname set." );
}

sub cmd_debug {
    my( $heap ) = $_[ HEAP ];
    my $user = $heap->{'default_player'};
    output( $heap, "Current user object: $user" );
    if ( $user->referee_jid ) {
        output( $heap, "Current ref JID: ".$user->referee_jid );
    }
}

sub cmd_help {
    my( $heap, $on ) = @_[ HEAP, &ARGS ];
    output( $heap, $_ ) for split /\n/, <<CMDLIST;
Volity client commands:

  CONNECTING
  connect [(JID) [(password)]] - creates a new connection.  If this is
                             the only connection then it is made
                             active.
  disconnect (JID) - disconnect JID
  use (JID)        - make JID the active connection
  connections      - list connections
  
  MESSAGING
  msg (JID) (text) - send private message to the given JID
  tmsg (text)      - send groupchat message to the current table
  rmsg (text)      - send private message to the current referee

  nick (nickname)  - set a new table nickname for yourself
  roster           - view your roster

  UI MANAGEMENT (Useful for UI development / debugging)
  load_ui (path)   - manually load a UI file
  clear_ui         - clear the current UI file from memory

  FINDING GAMES
  find             - call up the game finder
  lobby (menu #)   - join the given game's lobby
  tables (menu #)  - see a list of open tables playing the given game
  play (#)         - let the server choose a table for you

  STARTING GAMES
  new_table (JID)  - request a new table from the given server JID
  join_table (JID) - join an existing table
  invite (JID)     - invite another player to the table
  accept           - accept the last invitation you received
  add_bot          - request a new bot for the current table
  ready            - declare readiness to start a new game at current table
  unready          - withdraw a previous readiness declaration
  stand            - declare unwillingness to play, but remain at table
  sit              - delcare willingness to play (cancelling previous stand)

  MISCELLANY
  info             - see some info about your current status
  source (file)    - run commands from file
  help             - this list
  quit             - log off from Volity and exit this program
CMDLIST
  return unless $heap->{'commands'};
  output( $heap, "" );
  foreach (@{ $heap->{'commands'} }) {
    output( $heap, sprintf( "  %-16s - %s", $$_[0], $$_[1] ) );
  }
}

sub cmd_clear_ui {
    my $heap = $_[HEAP];
    my $user = $heap->{'default_player'};
    if ( defined $user->js ) {
        $user->js( undef );
        output( $heap, "OK, UI cleared." );
    } else {
        output( $heap, "Hmm, there wasn't any UI set." );
    }
}

sub cmd_load_ui {
    my( $heap, $filename ) = @_[ HEAP, &ARGS ];

    open( FILE, $filename )
        or return output( $heap, "Couldn't open $filename: $!" );
    my $source = join '', <FILE>;
    close FILE;

    $heap->{'default_player'}->load_js_from_source( $source );
    $heap->{'default_player'}->manual_ui_load( 1 );

}

sub js_writeln {
    my( $user, @output ) = @_;
    $user->print_message( "@output" );
}

sub js_rpc {
    my( $user, $cmd, @args ) = @_;
    
#    warn "Da command is: $cmd\n";
#    warn "Da args are: @args\n";

# XXX
#    $user->print_message( "Making RPC call to $cmd..." );
    $user->make_rpc_request({
        to         => $user->referee_jid,
        id         => "$cmd.".time,
        methodname => "game.$cmd",
        args       => \@args,
        handler    => sub {},
        });
}

sub js_registerCommand {
    my( $commands, $command, $shortdesc, $longdesc ) = @_;
    push @$commands, [ $command, $shortdesc, $longdesc ];
}

sub cmd_new_table {
    my( $heap, $server_jid ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ( defined $server_jid ) {
    }

    unless ($server_jid) {
	# A bare-named new_table command should be within a finder context.
	if ($user->server_menu) {
#	    use Data::Dumper; die Dumper($user->{server_menu});
	    if (not($user->server_menu->[0])) {
		$user->print_message("Use the game finder to choose a game to create, or enter a server JID directly.");
	    } elsif (not($user->server_menu->[1])) {
		# There's only one choice, so skip the menu.
		$server_jid = $user->server_menu->[0]->{jid};
		$user->print_message("Requesting new table at $server_jid...");
	    } else {
		# Make the user choose a server.
		$user->print_server_menu;
		return;
	    }
	} else {
	    # No server menu defined? We don't seem to be using the
	    # game finder, then.
	    return output( $heap, "Usage: new_table [game-server-jid]" );
	}
    }

    unless ( is_jid( $server_jid ) ) {
        return output( $heap, "That doesn't look like a JID to me!" );
    }
    
    $user->server_jid( $server_jid );
    $user->current_command( 'new_table' );
    if ( $user->js and $user->manual_ui_load ) {
        output( $heap, "UI file manually loaded, so I won't fetch another over the network." );
        output( $heap, "To force a fetch, use the clear_ui command, then rejoin this table." );
        $user->request_new_table( $server_jid );
    } else {
        output( $heap, "Requesting UI file from the Volity network." );
        $user->manual_ui_load( undef );
        $user->request_disco_info({ to=>$server_jid, id=>"server" });
    }
}

sub cmd_add_bot {
    my $user = $_[HEAP]->{'default_player'};
    unless ($user->referee_jid) {
	$user->print_message("You can't add a bot until you join a table.");
	return;
    }
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        to         => $user->referee_jid,
        id         => $rpc_id,
        methodname => 'volity.add_bot',
        handler    => 'add_bot',
        });
}

sub cmd_join_table {
  my( $heap, $table_jid ) = @_[ HEAP, &ARGS ];
  my $user = $heap->{'default_player'};

  unless ($table_jid) {
      $user->print_message("Usage: join_table [jid] OR join_table [menu #]");
      return;
  }

  # The $table_jid might be a numeric menu choice, and not a real JID.
  # Check for that first.
  if ($table_jid =~ /^\d+$/) {
      # Try treating it as a menu option.
      if ($user->table_menu->[$table_jid - 1]) {
	  $table_jid = $user->table_menu->[$table_jid - 1]->{table};
      } else {
	  $user->print_message("There is no table number '$table_jid' in the menu.");
	  return;
      }
  }

  # Check the validity of the JID.
  unless (check_jid( $heap, $table_jid )) {
      $user->print_message("This doesn't look like a valid Jabber ID to me: $table_jid");
      return;
  }

  if ( $user->js and $user->manual_ui_load ) {
      output( $heap, "UI file manually loaded, so I won't fetch another over the network.");
      output( $heap, "To force a fetch, use the clear_ui command, then rejoin this table.");
      $user->join_table($table_jid);
  } else {
      output( $heap,"You must load a UI file (with the load_ui command) before joining a table.");
      output( $heap,"(Friv does not yet support automatic UI fetching outside of table creation.)");
  }
}

sub cmd_tmsg {
    my( $heap, @message ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $message = join(' ', @message);
    unless ( defined $user->table_jid ) {
        return output( $heap,"Can't send a message to the table, since you're not at a table right now.");
    }
    unless ( defined $message ) {
        return output( $heap,"Beg your pardon? (Usage: tmsg [message-text])");
    }
    $user->send_message({
        type => 'groupchat',
        body => $message,
        to   => $user->table_jid,
        });
}

sub cmd_msg {
    my( $heap, $to, @message ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $message = join(' ', @message);
    unless ( defined $message ) {
        return output( $heap,"Beg your pardon? (Usage: msg [to-jid] [message-text])");
    }
    return unless check_jid($_[HEAP], $to);
    $user->send_message({
        type => 'normal',
        body => $message,
        to   => $to,
        });
}

sub cmd_ready {
    my( $heap ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ( defined $user->table_jid ) {
      return output( $heap,"Can't start a new game, because you're not seated at a table.");
    }
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        id         => $rpc_id,
        to         => $user->referee_jid,
        methodname => 'volity.ready',
        handler    => 'ready',
        });
}

sub cmd_stand {
    my( $heap ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ( defined $user->table_jid ) {
      return output( $heap,"You're not seated at a table.");
    }
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        id         => $rpc_id,
        to         => $user->referee_jid,
        methodname => 'volity.stand',
        handler    => 'stand',
        });
}

sub cmd_sit {
    # Sitting is actually just an alias to an unreadiness call request,
    # since they really do the same thing.
    return cmd_unready(@_);
}

sub cmd_unready {
    my( $heap ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ( defined $user->table_jid ) {
      return output( $heap,"You're not at a table.");
    }
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        id         => $rpc_id,
        to         => $user->referee_jid,
        methodname => 'volity.unready',
        handler    => 'unready',
        });
}

sub cmd_rmsg {
    my( $heap, @message ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $message = join(' ', @message);
    unless (defined($user->referee_jid)) {
        return output( $heap,"Can't send a message to the referee, since you're not at a table right now.");
    }
    unless (defined($message)) {
        return output( $heap,"Beg your pardon? (Usage: rmsg [message-text])");
    }
    $user->send_message({
        type => 'normal',
        body => $message,
        to   => $user->referee_jid,
        });
}

sub cmd_roster {
    my( $heap ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $roster = $user->roster;
    my @jids = sort( $roster->jids );
    my @available_jids;
    my @unavailable_jids;
    for my $jid ( @jids ) {
        my @presence_list = $roster->presence( $jid );
        if ( @presence_list and grep { not defined $$_{type} or $$_{type} ne 'unavailable'} @presence_list ) {
            push @available_jids, $jid;
        } else {
            push @unavailable_jids, $jid;
        }
    }
    output( $heap, "----AVAILABLE----" );
    if ( @available_jids ) {
        for my $jid ( @available_jids ) {
#          output( $heap,$_);
          for my $presence ( $roster->presence( $jid ) ) {
            my $full_jid = $jid;
            if ( defined $$presence{'resource'} ) {
                $full_jid .= "/$$presence{resource}";
            }
            output( $heap, $full_jid );
          }
        }
    } else {
        output( $heap,"Nobody in your roster is online.");
    }
    if ( @unavailable_jids ) {
        output( $heap, "----UNAVAILABLE----" );
        foreach ( @unavailable_jids ) {
            output( $heap,$_);
        }
    }
}

sub cmd_find {
    my( $heap ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    $user->request_disco_items({
	to=>$user->bookkeeper_jid,
	id=>'finder',
	node=>'rulesets',
    });
}

sub cmd_lobby {
    my( $heap, $menu_choice ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ($menu_choice) {
	$user->print_message("Usage: lobby (game #)");
	$user->print_message("...where (game #) is one of the menu option numbers resulting from\nthe 'find' command.");
	    return;
    }
    my $ruleset_item = $user->ruleset_menu->[$menu_choice - 1];
    unless ($ruleset_item) {
	$user->print_message("That doesn't appear to be a menu option.");
	return;
    }
    # Issue a lobby-discovering disco request to the server.
    $user->request_disco_items({
	to=>$user->bookkeeper_jid,
	id=>'lobby',
	node=>$ruleset_item->node . "|lobby",
    });
}

sub cmd_tables {
    my( $heap, $menu_choice ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ($menu_choice) {
	$user->print_message("Usage: tables (game #)\n...where (game #) is one of the menu option numbers resulting from\nthe 'find' command.");
	    return;
    }
    my $ruleset_item = $user->ruleset_menu->[$menu_choice - 1];
    unless ($ruleset_item) {
	$user->print_message("That doesn't appear to be a menu option.");
	return;
    }
    my @servers = $user->servers_for_ruleset($ruleset_item->node);
    if (@servers) {
	$user->server_menu(\@servers);
	my @tables = $user->tables_for_servers(@servers);
	if (@tables) {
	    $user->table_menu(\@tables);
	    $user->print_table_menu;
	} else {
	    $user->print_message("There are no open tables for that ruleset.");
	}
    } else {
	$user->print_message("There are no active servers for that ruleset. (How strange...)");
    }
    
}

package Volity::User;

use warnings;
use strict;

use base qw(Volity::Jabber);
use fields qw(nick output poe_heap table_jid referee_jid server_jid js opponents available_uis current_ui_url bookkeeper_jid uis_to_check current_command manual_ui_load ruleset_menu table_menu server_menu server_timeout awaiting_referee_list awaiting_table_info awaiting_server_list alarm_ids servers_by_ruleset waiting_for_servers salient_servers responding_servers salient_referees responding_referees is_ready invitation);
use POE;

sub init_finish {
  my $self = $_[OBJECT];
  
  my $jid = $_[ARG0];
  
  # Succesful login!
  $self->print_message("Connection successful. Weclome to Volity.");
  $self->request_roster;

  # Initialize some instance variables.
  $self->server_timeout(2);	# How long (secs) to wait for disco responses
  foreach (qw(current_ui_url awaiting_server_list awaiting_referee_list awaiting_table_info alarm_ids servers_by_ruleset salient_servers responding_servers salient_referees responding_referees)) {
      $self->$_({});
  }
  foreach (qw(table_menu ruleset_menu server_menu)) {
      $self->$_([]);
  }

}

sub receive_roster {
  my $self = shift;
  $self->SUPER::receive_roster(@_);
  # Having built our roster, we'll now announce our presence to the server.
  $self->send_presence;
}

sub print_message {
  my $self = shift;
  my ($message) = @_;
  &{ $self->output }( $self, $message );
}

sub rpc_response_new_table {
  my $self = shift;
  my( $message ) = @_;
  my $table_jid = $$message{'response'};
  $self->join_table($table_jid);

  my ($ref_resource) = $table_jid =~ /^(.*?)@/;
  my $ref_jid = $$message{'from'};
  $self->print_message("New table made, and joined. (Table JID: $table_jid)");
}

sub _rpc_receive_invitation {
    my $self = shift;
    my ($sender_jid, $invitation) = @_;
    $self->print_message("$sender_jid has invited you to a game!");
    if ($invitation->{message}) {
       $self->print_message("This message was attached:");
       $self->print_message($invitation->{message});
    }
    $self->print_message("Use the 'accept' command to accept the invitation.");
    $self->invitation($invitation);
    return 1;
}

sub _rpc_player_ready {
    my $self = shift;
    my ($sender_jid, $player_nickname) = @_;
    $self->print_message("$player_nickname is ready to play.");
    return 1;
}

sub _rpc_player_unready {
    my $self = shift;
    my ($sender_jid, $player_nickname) = @_;
    $self->print_message("Oops; $player_nickname is no longer ready to play.");
    return 1;
}

sub _rpc_start_game {
    my $self = shift;
    # Tell the UI to get going.
    main::js_call($self->js, 'START');
}

sub _rpc_end_game {
    my $self = shift;
    # Tell the UI to end the game.
    main::js_call($self->js, 'END');
}

sub _rpc_player_sat {
    my $self = shift;
    my ($sender_jid, $player_nickname) = @_;
    $self->print_message("$player_nickname sits, joining as a player.");
    if ($self->is_ready) {
	$self->print_message("This has made you unready.");
	$self->is_ready(0);
    }
}

sub _rpc_player_stood {
    my $self = shift;
    my ($sender_jid, $player_nickname) = @_;
    $self->print_message("$player_nickname stands up, no longer wishing to play.");
    if ($self->is_ready) {
	$self->print_message("This has made you unready.");
	$self->is_ready(0);
    }
}

sub fetch_ui_file {
    my $self = shift;
    my ($url) = @_;

    my $agent = LWP::UserAgent->new;

    # Now, at this point, we can do sexy things, like look at what we already
    # might have cached from previous forays to this URL.
    # Today, no sexiness. We will grab the URI file blindly and crush
    # whatever we last downloaded with the same name.
    # Sexiness tomorrow, maybe.
    my $request = HTTP::Request->new(GET=>$url);
    my $response = $agent->request($request);
    my $local_zipfile = File::Spec->catfile($working_dir, "ui.zip");
    open (ZIP, ">$local_zipfile") or die "Can't write ui zipfile $local_zipfile: $!\n";
    print ZIP $response->content;
    close (ZIP) or die "Can't close zipfile $local_zipfile: $!\n";
    my $zip_reader;
    unless ($zip_reader = Archive::Zip->new($local_zipfile)) {
        $self->print_message("Oh, there was a problem reading the zipfile $local_zipfile. Sorry.");
        return;
    }
    my $js_fh;
    my @js_source;
    if ($js_fh = Archive::Zip::MemberRead->new($zip_reader, "main")) {
	warn "OK.";
        while (defined(my $line = $js_fh->getline)) { 
            push (@js_source, $line);
        }
    } else {
        $self->print_message("The archive $local_zipfile doesn't seem to have a main file. I can't use it. Sorry...");
        return;
    }

    unless (@js_source) {
	$self->print_message("The archive $local_zipfile doesn't seem to have any JavaScript content. I can't use it. Sorry...");
	return;
    }

    # Having done all that, create the JS interpreter.

    $self->load_js_from_source(join("\n", @js_source));

    # Now make the actual RPC request.

    if ($self->current_command eq 'new_table') {
        $self->request_new_table($self->server_jid);
    } elsif ($self->current_command eq 'accept_invitation') {
        $self->join_table($self->invitation->{table});
    }

}

sub request_new_table {
    my $self = shift;
    my ($server_jid) = @_;
    my $rpc_id = 'new-table';
    $self->make_rpc_request(
                            {
                                to=>$self->server_jid,
                                id=>$rpc_id,
                                methodname=>'volity.new_table',
                                handler=>'new_table',
                            }
                            );
}

sub join_table {
    my $self = shift;
    my ($table_jid) = @_;
    $self->clear_opponent_nicknames;
    $self->join_muc(
                  {
                   jid=>$table_jid,
                   nick=>$self->nick || $self->user,
                  }
                 );
  $self->table_jid($table_jid);
}

sub load_js_from_source {
    my $self = shift;
    my ($js_source) = @_;
    my $commands = $self->poe_heap->{commands} ||= [];

    my $js = JavaScript::SpiderMonkey->new();
    $js->init();
    my $game = $js->object_by_path("game");
    my $referee = $js->object_by_path("client");
    my $info = $js->object_by_path("info");
    $js->function_set("writeln", sub { main::js_writeln( $self, @_) } );
    $js->function_set("rpc", sub { main::js_rpc( $self, @_ ) } );
    $js->function_set("registerCommand", 
                      sub { main::js_registerCommand( $commands, @_ ) } , $referee );

    {
	local $SIG{__WARN__} = sub {};
	$js->eval( $js_source );
    }

    $js->eval( "info.nickname = '" . ($self->nick || $self->user) . "'" );
    $js->eval( "info.opponents = {}" );
    for my $nickname ($self->opponent_nicknames) {
        $js->eval( "info.opponents['$nickname'] = {}" );
    }
    if ($self->js) {
        $self->js->destroy;
    }
    $self->js( $js );
}

sub rpc_response_add_bot {
  my $self = shift;
  my( $message ) = @_;
  $self->print_message("Response from the bot-add request was: $$message{'response'}");
}

sub rpc_response_invite_player {
    my $self = shift;
    $self->print_message("The invitation has been sent.");
}

sub rpc_response_ready {
  my $self = shift;  
  $self->print_message("You're ready to play. (Use the 'unready' command to cancel.)");
  $self->is_ready(1);
}

sub rpc_response_unready {
    my $self = shift;
    $self->print_message("You are sitting, but not ready to play. (Use the 'ready' command when you are ready.)");
}

sub rpc_response_default {
  my $self = shift;
  my ($message) = @_;
  $self->print_message("Received an RPC response with id ".
    "$$message{'id'}, but I don't know how to handle it.");
}

sub rpc_response_stand {
    my $self = shift;
    $self->print_message("You are no longer playing. (Use the 'sit' command to cancel.)");
}

sub handle_rpc_transmission_error {
  my $self = shift;
  my ($iq, $code, $error_message) = @_;
  my $full_message = "Failed to send an RPC packet. Error: $code";
  if (defined($error_message)) {
    $full_message .= " - $error_message";
  }
  $self->print_message($full_message);
}

sub handle_rpc_fault {
  my $self = shift;
  my ($fault_hash) = @_;
  my $full_message = "Received an RPC fault response: ";
  $full_message .= join(' - ', $$fault_hash{fault_code}, $$fault_hash{fault_string});
  $self->print_message($full_message);
}

sub handle_rpc_request {
  my $self = shift;
  my ($req) = @_;
  my $sub;
  if ($$req{method} =~ /^volity\.(\w+)/) {
      my $rpc_method = $1;
      my $local_method = "_rpc_$rpc_method";
      my $return_value;
      if ($self->can($local_method)) {
          my @return_values = $self->$local_method($$req{from}, @{$$req{args}});
          if (@return_values < 2) {
              $self->send_rpc_response($$req{from}, $$req{id}, @return_values);
          } else {
              $self->send_rpc_fault($$req{from}, $$req{id}, @return_values);
          }
      } else {
          warn("Got bogus RPC request, '$$req{method}'");
      }
  } elsif ($$req{'method'} =~ /^game\.(\w+)/) {
      main::js_call( $self->js, $$req{'method'}, @{ $$req{'args'} } );
  } else {
      $self->print_message("Unknown rpc request namespace: $$req{'method'}");
  }
}

sub handle_normal_message {
  my $self = shift;
  my ($message) = @_;
  $self->print_message("From: $$message{from}");
  $self->print_message("$$message{body}");
}

sub handle_chat_message {
  my $self = shift;
  my ($message) = @_;
  $self->print_message("From: $$message{from}");
  $self->print_message("$$message{body}");
}

sub handle_groupchat_message {
  my $self = shift;
  my ($message) = @_;
  my ($sender_nickname) = $$message{from} =~ /\/(.*)$/;
  $sender_nickname ||= $$message{from};
  $$message{body} ||= '';
  $self->print_message("$sender_nickname: $$message{body}");
}

# This presence handler detects a table's referee through MUC attributes.
# It also watches for general presence updates, and updates the user's
# internal roster object as needed.
sub jabber_presence {
  my $self = shift;
  my ($node) = @_;
  my $x; # Hey, that's the name of the element, OK?
  if (defined($node->attr('type')) and $node->attr('type') eq 'error') {
    # Ruh roh. Just print an error message.
    my $error = $node->get_tag('error');
    my $code = $error->attr('code');
    $self->print_message("Got an error ($code):");
    my $message = $error->data || "Something went wrong.";
    $self->print_message($message);
    return;
  }
  if (($node->get_tag('x')) and (($x) = grep($_->attr('xmlns') eq "http://jabber.org/protocol/muc#user", $node->get_tag('x')))) {
    # Aha, someone has joined the table.
    my $new_person_jid = $x->get_tag('item')->attr('jid');
    my $affiliation = $x->get_tag('item')->attr('affiliation');
    if ($affiliation eq 'owner') {
      # This is the table's ref.
      $self->referee_jid($new_person_jid);
    } else {
      # This is a potential opponent!
      unless ($node->attr('type')) {
        # No 'type' attribute means they're joining us...
        # Save the nickname. We'll pass it to the UI file later.
        $self->add_opponent_nickname($node->attr('from'));
      } elsif ($node->attr('type') eq 'unavailable') {
        # Oh, they're leaving...
        $self->remove_opponent_nickname($node->attr('from'));
      }
    }
  } elsif ($self->roster->has_jid( $node->attr('from') )) {
    # Someone on our roster just changed their presence.
    my $roster = $self->roster;
    my $jid = $node->attr('from');
    my $presence_hash = {type=>$node->attr('type')};
    foreach (qw(show status priority)) {
      $$presence_hash{$_} = $node->get_tag($_)->data if $node->get_tag($_);
    }
    $roster->presence($jid, $presence_hash);
    my $prez = $roster->presence($jid);
  }
}

sub handle_disco_info {
    my $self = shift;
    my ($from, $id, $items, $fields) = @_;
    my @items = @$items;

    # The value of $id indicates what sort of Volity entity sent the packet.
    if ($id =~ /^ruleset-ui(\d+)$/) {
        my $id_number = $1;
        my $current_ui_url = $self->current_ui_url->{$id_number};
        my @types = @{$$fields{"client-type"}};
        if (grep($_ eq 'http://volity.org/protocol/ui/text', @types)) {
            # Good, this one is available to us.
            push (@{$self->{available_uis}},
                  {
                      url=>$current_ui_url,
                      description=>$$fields{description}->[0],
                      reputation=>$$fields{reputation}->[0],
                  },
                  );
        }
        $self->{uis_to_check} -= 1;
        unless ($self->uis_to_check) {
            if (@{$self->available_uis} > 1) {
                $self->show_ui_menu;
            } elsif (@{$self->available_uis}) {
                my $ui = $self->available_uis->[0];
                $self->print_message("Fetching game UI file from $$ui{url}...");
                $self->fetch_ui_file($$ui{url});
            } else {
                $self->print_message("No text UIs available for this game. Sorry.");
            }
        }

    } elsif ($id eq 'server') {
        my ($ruleset_uri) = @{$$fields{ruleset}};
        my ($ruleset_version) = @{$$fields{"ruleset-version"}};

        $self->discover_uis_for_ruleset($ruleset_uri);
    } elsif ($id =~ /^table-info-request-(.*)$/) {
	# This referee is telling us about its table.
	my $referee_jid = $1;
	$self->logger->debug("New table info from $referee_jid.");
	my %table_info;
	foreach ("max-players", "server", "table", "afoot", "players", "language", "name") {
	    $table_info{$_} = $$fields{$_}->[0];
	}
#	$self->table_menu->{keys(%{$self->table_menu}) + 1} = \%table_info;
	push (@{$self->table_menu}, \%table_info);
    } elsif ($id =~ /^server-info-request-(.*)$/) {
	my $server_jid = $1;
	my ($server_info) = $self->salient_servers->{$server_jid};
	$server_info->{name} = "Billy bob's bar-b-q";
	$self->responding_servers->{$server_jid} = $server_jid;
    } else {
        $self->print_message("Um... I got a disco info response with id $id. I'm not sure what to do about it.");
    }
}

# discover_uis_for_ruleset: make a disco request for a given ruleset's
# ui-items.
# WARNING! The way this is presently coded, this plugs into a chain reaction
# that will end up in a UI being downloaded. Well... so be it.
sub discover_uis_for_ruleset {
    my $self = shift;
    my ($ruleset_uri) = @_;
    
    $self->request_disco_items({to=>$self->bookkeeper_jid,
                                id=>'ruleset',
                                node=>$ruleset_uri . "|uis",
                            });
}

sub handle_disco_items {
    my $self = shift;
    my ($from, $id, $items) = @_;
    my @items = @$items;
    
    if ($id eq 'ruleset') {
        $self->available_uis([]);
        $self->uis_to_check(scalar(@items));
        my $id_num = 0;
        for my $item (@items) {
            my $iq_id = "ruleset-ui" . ++$id_num;
            $self->current_ui_url->{$id_num} = $item->node;
            $self->request_disco_info({to=>$item->jid, 
                                  id=>$iq_id,
                                  node=>$item->node,
                              });
        }
    } elsif ($id eq 'finder') {
	if (@items) {
	    my @menu;
	    for my $item (@items) {
		push (@menu, $item);
	    }
	    $self->ruleset_menu(\@menu);
	    $self->print_ruleset_menu;
	} else {
	    $self->print_message("Worryingly, the bookkeeper doesn't seem to know about any game categories. Er...");
	}
    } elsif ($id eq 'lobby') {
	if (@items) {
	    # We'll just use the one lobby for now.
	    my $lobby_jid = $items[0]->jid;
	    $self->print_message("Joining lobby (at $lobby_jid)...");
	    $self->join_muc({
		jid=>$lobby_jid,
		nick=>$self->nick || $self->user,
	    });
	} else {
	    $self->print_message("Oddly, I can't find the lobby for that game. Sorry.");
	}
    } elsif ($id eq 'servers') {
	# Stuff a hashref representation of the server into an dictionary
	# called 'salient servers' which the servers_for_ruleset() sub
	# (which is probably executing in another POE thread) will use.
	foreach (@items) {
	    my $server_info = {jid=>$_->jid};
	    $self->salient_servers->{$_->jid} = $server_info;
	}

	# We're done waiting, so signal the other POE parts.
	$self->waiting_for_servers(0);

    } elsif ($id =~ /^referee-list-request-(.*)$/) {
	# This server is telling us about its non-hidden referees.
	foreach (@items) {
	    $self->salient_referees->{$_->jid} = $_->jid;
	}
	my $server_jid = $1;
	$self->responding_servers->{$server_jid} = 1;
	$self->logger->debug("New referee list from $server_jid.");
#	# The @items array holds referee information.
#	# Ask the bookkeeper for the skinny on this server.
#	$self->get_server_reputation($server_jid);
#	# We will ask each referee for info about its table.
#	$self->get_table_info_from_referees(@items);
#	# We're no longer waiting for a response from this server...
#	delete($self->awaiting_referee_list->{$server_jid});
#	unless (keys(%{$self->awaiting_referee_list})) {
#	    # OK, all the servers have reported back. We don't need to
#	    # wait any longer.
#	    $self->kernel->delay_adjust($self->alarm_ids->{referee_list},
#					0,
#					);
#	}
    }
}
    
sub get_server_reputation { }

sub tables_for_servers {
    my $self = shift;
    my @servers = @_;
    my $deadline;

    # Get referees from all servers.
    $deadline = time + $self->server_timeout;
    for my $server (@servers) {
	# Do a disco for refs
	my $server_jid = $server->{jid};
	$self->logger->debug("Asking $server_jid for its referees.");
	$self->request_disco_items({
	    to=>$server_jid,
	    id=>"referee-list-request-$server_jid",
	    node=>"open_games",
	});
    }
    until ((time == $deadline) or (values(%{$self->responding_servers}) == @servers)) {
	$self->kernel->run_one_timeslice;
    }

    # We have all the refrees we care about stored in $self->salient_referees.
    # Ask them what tables they have.
    $deadline = time + $self->server_timeout;
    for my $referee_jid (values(%{$self->salient_referees})) {
	$self->logger->debug("Asking $referee_jid for its info.");
	$self->request_disco_info({
	    to=>$referee_jid,
	    id=>"table-info-request-$referee_jid",
	});
    }
    until ((time == $deadline) or (values(%{$self->responding_referees}) == values(%{$self->salient_referees}))) {
	$self->kernel->run_one_timeslice;
    }

    # Now, all the table info hashes are in $self->table_menu.

    # Clean up scratchpads.
    $self->responding_servers({});
    $self->salient_referees({});
    $self->responding_referees({});

    # And return the table menu because it's nice to return things.
    return @{$self->table_menu};
}

sub servers_for_ruleset {
    my $self = shift;
    my ($ruleset_uri) = @_;
    unless ($self->servers_by_ruleset->{$ruleset_uri}) {
	$self->print_message("One moment while I fetch server information...");
	$self->request_disco_items({
	    to=>$self->bookkeeper_jid,
	    id=>'servers',
	    node=>$ruleset_uri . '|servers',
	});
	$self->waiting_for_servers(1);
	until (not($self->waiting_for_servers)) {
	    $self->kernel->run_one_timeslice;
	}
	my $deadline = time + $self->server_timeout;
	for my $server_info (values(%{$self->salient_servers})) {
	    $self->request_disco_info({
		to=>$server_info->{jid},
		id=>"server-info-request-" . $server_info->{jid},
	    });
	}
	until ((time == $deadline) or (values(%{$self->responding_servers}) == values(%{$self->salient_servers}))) {
	    $self->kernel->run_one_timeslice;
	}
	# Winnow out any servers who didn't respond to that info call.
	for my $jid (keys(%{$self->salient_servers})) {
	    unless ($self->responding_servers->{$jid}) {
		delete($self->salient_servers->{$jid});
	    }
	}

	$self->servers_by_ruleset->{$ruleset_uri} = [values(%{$self->salient_servers})];
	# Clean up the scratchpads.
	$self->salient_servers({});
	$self->responding_servers({});
    }

    return @{$self->servers_by_ruleset->{$ruleset_uri}};
}

# get_referee_lists_from_servers: Send out disco requests to the given
# servers, asking what referees they have available.
sub OLD_get_referee_lists_from_servers {
    my $self = shift;
    my (@server_items) = @_;
    # Set a timer. All the servers will have to check in by this deadline.
    # When it's up, we'll print the table menu, _unless_ we are still
    # waiting for referees to respond.
    $self->kernel->state('referee_timeout', 
			 sub {
			     my $self = $_[ARG0];
			     delete($self->alarm_ids->{referee_list});
			     unless($self->alarm_ids->{table_info}) {
				 $self->print_table_menu;
			     }
			   },
			 );
    $self->alarm_ids->{referee_list} = 
	$self->kernel->delay('referee_timeout', $self->server_timeout, $self);
    foreach my $server_item (@server_items) {
	my $jid = $server_item->jid;
	$self->awaiting_referee_list->{$jid} = 1;
	my $request_id = "referee-list-request-$jid";
	$self->logger->debug("Making referee-list request to $jid, id $request_id");
	$self->request_disco_items({
	    to=>$jid,
	    id=>$request_id,
	    node=>'referees',
	});
    }
}

sub OLD_get_table_info_from_referees {
    my $self = shift;
    my (@referee_items) = @_;
    # Set a timer. All the servers will have to check in by this deadline.
    # When it's up, we'll print the table menu, _unless_ we are still
    # waiting for referees to respond.
    $self->kernel->state('table_timeout', 
			 sub {
			     my $self = $_[ARG0];
			     delete($self->alarm_ids->{table_info});
			     unless($self->alarm_ids->{referee_list}) {
				 $self->print_table_menu;
			     }
			   },
			 );
    $self->alarm_ids->{referee_list} = 
	$self->kernel->delay('table_info', $self->server_timeout, $self);
    foreach my $referee_item (@referee_items) {
	my $jid = $referee_item->jid;
	$self->awaiting_table_info->{$jid} = 1;
	my $request_id = "table-info-request-$jid";
	$self->logger->debug("Making table-info request to $jid, id $request_id");
	$self->request_disco_info({
	    to=>$jid,
	    id=>$request_id,
	});
    }
}
    

sub print_ruleset_menu {
    my $self = shift;
    $self->print_message("Games you can play:");
    my $number = 1;
    for my $ruleset_item ($self->ruleset_menu) {
	my $name = $ruleset_item->name;
	$self->print_message("$number\t$name");
	$number++;
    }
    $self->print_message("You may now use the 'lobby' or 'tables' commands with one of");
    $self->print_message("the above numbers.");
}

sub print_server_menu {
    my $self = shift;
    if (($self->server_menu)) {
	my $number = 1;
	for my $server_item ($self->server_menu) {
	    $self->print_message($number++ . $server_item->{jid});
	}
	$self->print_message("Type 'new_table [#]' to create a new table on one of these servers.");
    } else {
	$self->print_message("There are no known servers for this ruleset.");
    }
}

sub print_table_menu {
    my $self = shift;
    if ($self->table_menu) {
	my $number = 1;
	for my $table_info ($self->table_menu) {
	    my $table_line = sprintf("% 2d: %s Players:(%d/%d)",
				     $number++,
				     $table_info->{name},
				     $table_info->{players} || 0,
				     $table_info->{'max-players'},
				     );
	    my $server_line = sprintf("    Server rating: %d", 0);
	    $self->print_message($table_line);
	    $self->print_message($server_line);
	    $self->print_message("    Language: " . $table_info->{language});
	}
	$self->print_message("Join a table with 'join_table [#]'.");
    } else {
	$self->print_message("No tables are available for this game.");
    }
    $self->print_message("You can start a new table with 'new_table'.");
}
	

# add_opponent_nickname: Add the given nickname (either a full JID in MUC
# format, or a bare string containing only the nickname) to our internal
# list of known opponents at the current table.
sub add_opponent_nickname {
  my $self = shift;
  my ($name) = @_;
  my $nickname;
  if (main::is_jid($name)) {
    ($nickname) = $name =~ /\/(.*)$/;
    unless ($nickname) {
      die "GACK. I couldn't tease a nickname out of the jid $name.";
    }
  } else {
    $nickname = $name;
  }
  my $my_nickname = $self->nick || $self->user;
  unless ($my_nickname eq $nickname) {
    $self->{opponents}{$nickname} = 1;
  }
}

sub remove_opponent_nickname {
  my $self = shift;
  my ($name) = @_;
  my $nickname;
  if (main::is_jid($name)) {
    ($nickname) = $name =~ /\/(.*)$/;
    unless ($nickname) {
      die "GACK. I couldn't tease a nickname out of the jid $name.";
    }
  } else {
    $nickname = $name;
  }
  return(delete($self->{opponents}{$nickname}));
}

sub opponent_nicknames {
  my $self = shift;
  return keys(%{$self->{opponents}});
}

sub clear_opponent_nicknames {
  my $self = shift;
  $self->{opponents} = {};
}

=head1 NAME

Friv - A simple text-only Volity client

=head1 SYNOPSIS

 $ friv -u myusername -p mypassword -h volity.net

 Connection successful. Weclome to Volity.
 Volity> new_table rps@volity.net/testing   
 Requesting UI file from the Volity network.
 Fetching game UI file from http://volity.org/games/rps/text/rps.zip...
 rps.js Loaded!
 New table made, and joined.
 Volity> add_bot
 Response from the bot-add request was: ok
 Volity> start_game
 The game has begun. Good luck!
 RPS begins!  Have fun and good luck!
 RandomBot: I have made my move.
 Volity> select rock
 Good old rock! Nothing beats rock.

 [etc....]

=head1 DESCRIPTION

This program provides a very simple text-based interface to the Volity
network. It will let you create or join tables at any game server, so
long as a text-based UI file for that server's game is available.

Friv is part of I<Frivolity>, the Perl implementation of the Volity
network game platform. While it aims to be a full-featured Volity
client, it is more geared towards testing and hacking than general
use. For a more user-friendly Volity experience, we recommend a
GUI-based client, such as Javolin.

To learn more about Volity, visit the Volity developers' webesite at
http://volity.org.

=head1 USAGE

To play a game, use the C<new_table> command (see L<"COMMANDS">) to
create a new Volity table. You can then call C<add_bot> to summon
automated players (if the server supports them), or have your friends
join through their own clients. (Friv does not support any sort of
invitation mechanism yet.)  When you are ready to start playing, call
C<start_game>.

Like all Volity clients, Friv requires an appropriate set of
user-interface files before you can play a game. When you request a
new table, Friv will automatically negotiate with the specified server
in an attempt to locate a text-friendly UI file to download and
use. If successful, it transparently sets up everything it needs and
escorts you to the new table. Otherwise, you'll receive an apologetic
message.

After joining a table, use the C<help> command to see both a summary
of Friv's global commands I<and> the commands specific to the game UI
currently laoded. For example, the "select" command shown in
L<"SYNOPSIS"> was defined by the rock-paper-scissors UI file that Friv
transparently loaded when that user created a table at a
rock-paper-scissors game server.

You can also use the C<join_table> command to join a game table that
someone else has already created. Unfortunately, Friv currently lacks
the ability to fetch UI files when joining tables in this fashion; you
will have to have your own local copy of that file, and C<load_ui> on
it before joining.

=head1 RUNNING

Friv takes the following flags on launch:

=head2 Required flags

These flags set information that Friv needs to authenticate you with a
Volity (Jabber) server.

If you don't supply these as command flags, the program will prompt
you for them. (Supplying your password in this way offers more
security than supplying it on the command line.)

=over

=item u

The account's username.

=item h

The account's host. Examples: volity.net, jabber.org.

=item p

The account's password.

=back

=head2 Optional flags

=over

=item b

The Volity bookkeeper JID to use. Defaults to
bookkeeper@volity.net. Unless you really know what you're doing, you
probably shouldn't change this.

=item f

The working directory that Friv can use to store its scratch
files. Defaults to "$ENV{HOME}/.friv".

=item l

A Log::Log4perl configuration file to use. (See L<Log::Log4perl>.)

=item o

The TCP port to connect to. Defaults to 5222 (Jabber's default port).

=item r

The resource to use with the Jabber account. Defaults to 'friv'.

=back

=head1 COMMANDS

=head2 Connecting and disconnecting

=over

=item connect C<JID> C<password>

Creates a new Jabber connection with the given Jabber ID and
password. Friv can support multiple simultaneous connections.

This command is executed for you if you specified login information
via command-line flags (see L<"RUNNING">).

=item use C<JID>

Makes the connection with the named JID active.

You don't need to invoke this if you have only one connection active.

=item disconnect C<JID>

Disconnects the connection with the provided JID from the Volity/Jabber network.

=item quit

Closes all network connections, and exits the program.

=back

=head2 Messaging

=over

=item msg C<JID> C<Message body>

Send the given text (as a 'normal'-type Jabber message) to the specifed JID.

=item tmsg C<Message body>

Send the given text (as a 'groupchat'-type Jabber message) to the table.

=item rmsg C<Message body>

Send the given text to the table's referee.

=item nick C<nickname>

Change your table/MUC nickname. By default, it's your username.

=back

=head2 UI management

These commands are mainly useful for UI development and debugging,
since Volity automates most UI management.

=over

=item load_ui C<filename>

Loads an ECMAScript UI file from the local filesystem. Useful if
you're testing a new UI file, or otherwise have a file that isn't
available over the network. If you load a UI file manually,
C<new_table> won't attempt to fetch a replacement over the network
unless you C<clear_ui> first.

Once you load a UI file, several new game-specific commands may
before available. Use the C<help> command to see a list of them (along
with all the other standard Friv commands).

=item clear_ui

Clears the currently loaded UI file from memory.

=back

=head2 Finding games

These commands let you interact with the Volity game finder, which let
you create and join game tables without directly handling raw
JabberIDs.

This is an experimental Volity feature, and so are these commands.

=over

=item find

Summons the game finder, displaying a menu of rulesets known to the Volity bookkeeper. Use the numbers from that menu as arguments with the following commands, as well as the C<new_table> command.

=item lobby C<find-menu-number>

Joins the discussion lobby of the given ruleset.

=item tables C<find-menu-number>

Lists the active, open tables of the given ruleset. You can use the numbers
from that menu as arguments with the C<join_table> command.

=back

=head2 Starting games

=over

=item new_table C<JID>

Attempt to create a new table at the specified JID. If successful, you
will immediately join the new table.

If you have not manually loaded a UI file (with C<load_ui>), Friv will
open negotiation with the specified server in order to find and load
an appropriate UI file by itself. It it cannot do so, you'll recieve
an explanatory error message, and no table will be created.

Optionally, after using the C<find> command, you can use a menu number
instead of a JID to start a new table at a server providing that menu
item's ruleset.

=item join_table C<JID>

Attempt to join the table (or Jabber groupchat) at the specifed JID.

Unfortunately, you must load a UI file manually (with C<load_ui>)
before calling this. Future versions of Friv will be able to fetch the
appropriate UI file over the network, much as with C<new_table>.

Optionally, after using the C<tables> command, you can use a menu number
instead of a JID to join that table.

=item add_bot

Summon a bot to the current table. Only works if the referee offers a
single bot type. (Friv currently lacks the form-support needed to
choose new bots.)

=item invite C<JID>

Sends an invitation to the player with the given jid. Only works if you are already seated at a table.

=item accept

Accepts the last invitation you received, and brings you to the table.

=item sit

Sits at the table, signaling that you are ready to play.

Note that you are standing when you first join a table.

Sitting causes all other players to become unready, since changing the
number (and identity) of players effectively the changes the table
conifguration.

=item stand

Stands up from the table, signaling that you no longer wish to be an
active player.

Standing causes all other players to become unready, since changing
the number (and identity) of players effectively the changes the table
conifguration.

=item ready

(Only works when you are seated.) Signals that you are ready
to play. The game begins once all the players have signaled readiness.

=item unready

(Only works when you are seated.) Signals that you are no longer ready
to play, but keeps you seated at the table.

=back

=head2 Miscellaneous commands

=over

=item info

Displays some debuggy information about your current Volity status.

=item source [filename]

Opens the named file and executes it as ECMAScript.

=item help

Displays a list of the standard Friv commands (as described in this
manpage), as well as any game-specific commands defined by the current UI
file (if there is one).

=back

=head1 BUGS

The most recent version of Friv represents the most advanced state of
the Volity platform. Since Volity is unfinished, so is Friv, and it
just about the same ways. On the other hand, Friv will continue to
develop so long as Volity does. Stay tuned.

=head1 AUTHOR

Jason McIntosh <jmac@jmac.org> (Jabber: jmac@volity.net)

=head1 COPYRIGHT

Copyright (c) 2004-2005 by Jason McIntosh

=head1 SEE ALSO

L<Volity>

http://volity.org

=cut

