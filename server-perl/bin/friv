#!/usr/bin/perl

=begin TODO

* Fix history browsing so that the cursor snaps back to the end when ya done.

=end TODO

=cut

use warnings;
use strict;

use POE;
use POE::Wheel::ReadLine;
sub ARGS() { ARG0..$#_ }
sub POE() { @_[0..(ARG0-1)] }
use JavaScript::SpiderMonkey;
use Data::JavaScript::Anon;
use Getopt::Std;
use YAML;
use LWP;
use File::Spec;
use Archive::Zip::MemberRead;
use Tie::ExecHash;

my %opts;
getopts( 'u:h:p:r:o:f:b:c:d', \%opts );
# u == username
# h == host
# p == password
# r == resource (friv)
# o == port (5222)
# f == friv dir
# b == bookkeeper (bookkeeper@volity.net/volity)
# c == command to run on start
# d == daemonize

################
# GLOBALS
################
my $next_rpc_request_id = 0;
my $last_message_recipient;
my $working_dir  = $opts{'f'} || File::Spec->catdir( $ENV{HOME}, ".friv" );
my $command_list = File::Spec->catdir( $working_dir, "client.yaml" );
our @cmd_hist    = eval { @{ YAML::LoadFile($command_list) } };
my $ui_dir       = File::Spec->catdir( $working_dir, "ui" );

# Make sure the working dir exists and is usable.
unless (-e $working_dir) {
    foreach ($working_dir, $ui_dir) {
	mkdir $_ or die "Tried to create working directory $_ but failed: $!";
    }
}

# Crank up the POE session that will manage our Jabber connection.
POE::Session->create(
    inline_states => {
        _start     => \&start,
        user_input => \&user_input,
        }
    );

POE::Kernel->run;


sub start {
    my( $session, $heap ) = @_[ SESSION, HEAP ];
    $heap->{'user'} = POE::Wheel::ReadLine->new(
        InputEvent => 'user_input',
        PutMode    => 'immediate',
        );
    foreach (@cmd_hist) {
        $heap->{'user'}->addhistory($_);
    }
    $heap->{'user'}->get( 'Volity> ' );
    my %env;
    tie( %env, 'Tie::ExecHash' );
    $heap->{'env'} = \%env;
    $heap->{'env'}{'connections'} = [
        sub {},                                            # SET
        sub { join ':', sort keys %{ $heap->{players} } }, # GET
        ];
    my @poe = &POE;
    $heap->{'env'}{'current_connection'} = [
        sub { cmd_use( @poe, $_[0] ) },
        sub {
            $heap->{'default_player'} ? 
              $heap->{'default_player'}->jid :
              ''
            },
        ];
    $heap->{'env'}{'username'}   = $opts{'u'};
    $heap->{'env'}{'resource'}   = $opts{'r'} || 'friv';
    $heap->{'env'}{'port'}       = $opts{'o'} || 5222;
    $heap->{'env'}{'host'}       = $opts{'h'};
    $heap->{'env'}{'bookkeeper'} = $opts{'b'} || 'bookkeeper@volity.net/volity';

    if ( $heap->{'env'}{'username'} and $heap->{'env'}{'host'} ) {
        act_connect( &POE, undef, $opts{'p'} );
    }

    if ( $opts{'c'} ) {
        run_command( &POE, $opts{c} );
    }
}

sub is_jid {
    my( $jid ) = @_;
    if ( $jid =~ /^[\w-]+@[\w-]+(?:\.[\w-]+)*(?:\/[\w-]+)?/ ) {
        return $jid;
    } else {
        return;
    }
}

sub check_jid {
    my( $heap, $jid ) = @_;
    if ( is_jid( $jid ) ) {
        return $jid;
    } else {
        output( $heap, "The string '$jid' doesn't look like a JabberID to me!" );
        output( $heap, "Command ignored." );
        return;
    }
}

END {
    YAML::DumpFile( $command_list, \@cmd_hist );
}

######################
# Input hanlding
######################

sub run_command {
    my( $heap, $line ) = @_[ HEAP, &ARGS ];
    my( $cmd, @args ) = tokenize( $line, $heap->{'env'} );
    $cmd = lc( $cmd );
    $cmd =~ s{\.}{_}g;
    return -1 if (not defined $cmd or $cmd eq '');
    if ( my $sub = __PACKAGE__->can( "cmd_$cmd" ) ) {
        &$sub( &POE, @args );
        return 1;
    }
    if ( $heap->{'commands'} ) {
       foreach (@{ $heap->{'commands'} }) {
           if ( $$_[0] eq $cmd ) {
               js_call( $heap->{'default_player'}->js, "client.$cmd", @args );
               return 1;
           }
       }
    }
    return 0;
}

sub user_input {
    my( $heap, $input, $exception ) = @_[ HEAP, &ARGS ];
    if ( defined $input ) {
        $heap->{'user'}->get('Volity> ');
        my $result = run_command( &POE, $input );
        if ( $result ) {
            return if $result == -1;
            $heap->{'user'}->addhistory( $input );
            push( @cmd_hist, $input );
        } else {
            output( $heap, "Unknown command: $input" );
        }
    } else {
        output( $heap, "Exception: $exception" );
        exit;
    }
}

sub js_call {
    my( $js, $cmd, @args ) = @_;
    my $script = "$cmd(";
    foreach ( @args ) {
        next if /^-?\d*(?:\.\d+)?$/;
	next if ref($_);
        s/'/\\'/g;
        $_ = "'$_'";
    }
    # Convert the @args into a list of JS-safe strings.
    my @js_args;
    for my $arg (@args) {
	if ( ref $arg ) {
	    push( @js_args, Data::JavaScript::Anon->anon_dump($arg) );
	} else {
	    push( @js_args, $arg );
	}
    }
    $script .= join ', ', @js_args;
    $script .= ")";
    return $js->eval( $script );
}

sub tokenize {
    my( $str, $vars ) = @_;
    my @tokens;
    my $tok_count = 0;
    my $last = 0;
    my $re = qr{\G(?:
        "([^"]+)(?<!\\)" | #1 Double quoted segment
        '([^']+)(?<!\\)' | #2 Single quoted segment
        (                  #3 Unquoted segment
          (?:               # one or more subsegments
            [^\s"']   |      # non-space/quote char
            (?<=\\)'  |      # escaped single quote
            (?<=\\)"  |      # escaped double quote
            (?<=\\)\s        # escaped double quote
          )+
        ) |
        ((?:(?<!\\)\s)+)   #4 One or more unescaped spaces
        )}x;
        #" quote is here to fix stupid joe syntax highlighter bug
    while ( $str =~ /$re/g ) {
        $last = pos( $str );
        my( $dq, $sq, $nq, $sp ) = ( $1, $2, $3, $4 );
        my $val = $dq || $sq || $nq || $sp;
        if ( $dq or $nq ) {
            $val = expand( $val, $vars );
        } else {
            $val = unescape( $val );
        }
        if ($sp) {
            $tok_count ++ if $#tokens == $tok_count;
        } else {
            $tokens[$tok_count] .= $val;
        }
    }
    if ($last < length($str)) {
        $tokens[$tok_count] .= substr( $str, $last );
    }
    return @tokens;
}

sub unescape {
    my( $str ) = @_;
    $str =~ s/\\(.)/$1/g;
    return $str;
}

sub expand {
    my( $str, $vars ) = @_;
    $str =~ s{
            (?:
            (?<!\\)\$(\w+) |
            \\(.)
            )
        }{
            if ($1) {
                if ( defined $$vars{$1} ) {
                    $$vars{$1};
                } else {
                    '';
                }
            } else {
                $2
            }
        }gxe;
    $str = unescape( $str );
    return $str;
}

sub find_player {
    my( $heap, $jid ) = @_;
    my $plist = $heap->{'players'};
    return $$plist{$jid} if exists $$plist{$jid};
    my @matches;
    foreach (keys %$plist) {
        if (/^\Q$jid\E/) {
            push @matches, $_;
        }
    }
    if (!@matches or @matches > 1) {
        return;
    }
    return $$plist{$matches[0]};
}

###########################
# User commands
###########################
sub output {
    my( $heap, @line ) = @_;
    $heap->{'user'}->put( join '', @line );
    return;
}

sub user_output {
    my( $self, $heap, @line ) = @_[ OBJECT, HEAP, &ARGS ];
    output( $heap, @line );
}

sub act_connect {
    my( $heap, $jid, $password ) = @_[ HEAP, &ARGS ];
    my( $username, $host, $resource );
    if ( $jid ) {
        ($username,$host,$resource) = 
            ( $jid =~ m{^([^@]+)@([^/]+)(?:/(.+))?$} )
            or die "Couldn't match u\@h/r from $jid\n";
    } else {
        $username = $heap->{'env'}{'username'};
        $host     = $heap->{'env'}{'host'};
    }
    $resource ||= $heap->{'env'}{'resource'};
    my $user = Volity::User->new({
        host           => $host,
        password       => $password,
        resource       => $resource,
        port           => $heap->{'env'}{'port'},
        alias          => $resource,
        user           => $username,
        poe_heap       => $heap,
        bookkeeper_jid => $heap->{'env'}{'bookkeeper'},
        });
    $jid = $user->jid;
    $heap->{'players'}{$jid}  = $user;
    $heap->{'default_player'} = $user;

    my @args = &POE;
    $args[OBJECT] = undef;
    $user->output( sub { $args[OBJECT] = shift; user_output( @args, @_ ); } );
}

sub cmd_echo {
    my( $heap, @args ) = @_[ HEAP, &ARGS ];
    output( $heap, join ' ', @args );
}

sub cmd_set {
    my( $heap, $var_value ) = @_[ HEAP, &ARGS ];
    if ( $var_value ) {
        my( $var, $value ) = split /=/, $var_value, 2;
        $heap->{'env'}{$var} = $value;
    } else {
        foreach ( sort keys %{ $heap->{'env'} } ) {
            output( $heap, "$_=".$heap->{'env'}{$_} )
                if defined $heap->{'env'}{$_};
        }
    } 
}

sub cmd_env { cmd_set( &POE ) }

sub cmd_connect {
    my( $heap, $session, $jid, $password ) = @_[ HEAP, SESSION, &ARGS ];
    if ( !$jid and (!$heap->{username} or !$heap->{host}) ) {
        return output( $heap, "connect: Must specify JID" );
    }
    if ( !$password ) {
        return output( $heap, "connect: Must specify password" );
    }
    eval {
        act_connect( @_ );
    };
    if ($@) {
        return output( $heap, 'connect: '.$@ );
    }
}

sub act_disconnect {
    my( $heap, $jid ) = @_[ HEAP, &ARGS ];

    $jid ||= $heap->{'default_player'}->jid;

    die "Can't disconnect $jid: Not connected.\n"
        unless exists $heap->{'players'}{$jid};

    $heap->{'players'}{$jid}->send_presence( {type=>'unavailable'} );

    delete $heap->{'players'}{$jid};
    delete $heap->{'default_player'}
        if $heap->{'default_player'} and
           $heap->{'default_player'}->jid eq $jid;
}

sub cmd_disconnect {
    my( $heap, $session, $jid ) = @_[ HEAP, SESSION, &ARGS ];
    if ( !$jid and !$heap->{'default_player'} ) {
        return output( $heap, "disconnect: Must specify JID" );
        return;
    }
    $jid ||= $heap->{'default_player'}->jid;
    my $player;
    unless ( $player = find_player( $heap, $jid ) ) {
        return output( $heap, 
            "disconnect: Couldn't find single JID matching $jid."
            );
    }

    eval {
        act_disconnect( &POE,  );
    };
    if ($@) {
        return output( $heap, "disconect: $@" );
    }
}

sub cmd_source {
    my( $heap, $file ) = @_[ HEAP, &ARGS ];
    my $fh;
    open( $fh, $file )
        or open( $fh, File::Spec->catdir($working_dir, $file) )
        or return output($heap,"source: Could not open $file: $!");
    while ( <$fh> ) {
        my $result = run_command( &POE, $_ );
        unless ( $result ) {
            output( $heap, "source: Unknown command: $_" );
        }
    }
    close( $fh );
}

no strict 'refs';
BEGIN { *{'cmd__'} = \&cmd_source; }
use strict 'refs';

sub cmd_connections {
    my( $heap, $session ) = @_[ HEAP, SESSION, &ARGS ];
    foreach ( sort keys %{ $heap->{'players'} } ) {
        my $active = ($heap->{'default_player'}->jid eq $_)?'* ':'';
        output($heap,"${active}$_");
    }
}

sub cmd_use {
    my( $heap, $session, $jid ) = @_[ HEAP, SESSION, &ARGS ];
    if ( !$jid ) {
        return output( $heap, "use: Must specify JID" );
    }
    my $player;
    unless ( $player = find_player( $heap, $jid ) ) {
        return output( $heap, "use: Couldn't find single JID matching $jid." );
    }
    $heap->{'default_player'} = $player;
}

sub cmd_info {
    my( $heap ) = $_[ HEAP ];
    no warnings 'uninitialized';
    my $user = $heap->{'default_player'};
    output( $heap, $_ ) for
        "Status information:",
        "  JID        : ".$user->jid,
        "  Nickname   : ".$user->nick,
        "  Table JID  : ".$user->table_jid,
        "  Referee JID: ".$user->referee_jid;
}

sub cmd_quit {
    my( $heap ) = $_[ HEAP ];
    output( $heap, 'Be seeing you.' );
    foreach (keys %{ $heap->{'players'} }) {
    	act_disconnect( &POE, $_ );
    }
    exit;
}

sub cmd_invite {
    my( $heap, $invited ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'user_obj'};
    unless ( $user->referee_jid ) {
        return output( $heap, "Create or join a table first!" );
    }
    unless ( $invited ) {
        return output( $heap, "Usage: invite [jid]" );
    }
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        to         => $user->referee_jid,
        id         => $rpc_id,
        methodname => 'volity.invite_player',
        args       => [$invited],
        handler    => 'invite_player',
        });

}

sub cmd_accept {
    my( $heap ) = $_[ HEAP ];
    my $user = $heap->{'user_obj'};
    if ( my $invitation = $user->invitation ) {
        $user->current_command( 'accept_invitation' );
        $user->discover_uis_for_ruleset( $$invitation{ruleset} );
    }
}

sub cmd_nick {
    my( $heap, $nickname ) = @_[ HEAP, &ARGS ];
    unless ( $nickname ) {
        return output( $heap, "Form: nick <nickname>" );
    }
    $heap->{'default_player'}->nick( $nickname );
    output( $heap, "Nickname set." );
}

sub cmd_debug {
    my( $heap ) = $_[ HEAP ];
    my $user = $heap->{'default_player'};
    output( $heap, "Current user object: $user" );
    if ( $user->referee_jid ) {
        output( $heap, "Current ref JID: ".$user->referee_jid );
    }
}

sub cmd_help {
    my( $heap, $on ) = @_[ HEAP, &ARGS ];
    output( $heap, $_ ) for split /\n/, <<CMDLIST;
Volity client commands:
  connect [(JID) [(password)]] - creates a new connection.  If this is
                             the only connection then it is made
                             active.
  disconnect (JID) - disconnect JID
  use (JID)        - make JID the active connection
  connections      - list connections
  
  msg (JID) (text) - send private message to the given JID
  tmsg (text)      - send groupchat message to the current table
  rmsg (text)      - send private message to the current referee

  nick (nickname)  - set a new table nickname for yourself
  roster           - view your roster

  load_ui (path)   - manually load a UI file
  clear_ui         - clear the current UI file from memory

  new_table (JID)  - request a new table from the given server JID
  join_table (JID) - join an existing table
  invite (JID)     - invite another player to the table
  accept           - accept the last invitation you received
  add_bot          - request a new bot for the current table
  start_game       - request a new game at the current table

  info             - see some info about your current status
  source (file)    - run commands from file
  help             - this list
  quit             - log off from Volity and exit this program
CMDLIST
  return unless $heap->{'commands'};
  output( $heap, "" );
  foreach (@{ $heap->{'commands'} }) {
    output( $heap, sprintf( "  %-16s - %s", $$_[0], $$_[1] ) );
  }
}

sub cmd_clear_ui {
    my $heap = $_[HEAP];
    my $user = $heap->{'default_player'};
    if ( defined $user->js ) {
        $user->js( undef );
        output( $heap, "OK, UI cleared." );
    } else {
        output( $heap, "Hmm, there wasn't any UI set." );
    }
}

sub cmd_load_ui {
    my( $heap, $filename ) = @_[ HEAP, &ARGS ];

    open( FILE, $filename )
        or return output( $heap, "Couldn't open $filename: $!" );
    my $source = join '', <FILE>;
    close FILE;

    $heap->{'default_player'}->load_js_from_source( $source );
    $heap->{'default_player'}->manual_ui_load( 1 );

}

sub js_writeln {
    my( $term, @output ) = @_;
    $term->put( "@output" );
}

sub js_rpc {
    my( $user, $cmd, @args ) = @_;
    
#    warn "Da command is: $cmd\n";
#    warn "Da args are: @args\n";

# XXX
#    $user->print_message( "Making RPC call to $cmd..." );
    $user->make_rpc_request({
        to         => $user->referee_jid,
        id         => "$cmd.".time,
        methodname => "game.$cmd",
        args       => \@args,
        handler    => sub {},
        });
}

sub js_registerCommand {
    my( $commands, $command, $shortdesc, $longdesc ) = @_;
    push @$commands, [ $command, $shortdesc, $longdesc ];
}

sub cmd_new_table {
    my( $heap, $server_jid ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ( defined $server_jid ) {
        return output( $heap, "Usage: new_table [game-server-jid]" );
    }
    unless ( is_jid( $server_jid ) ) {
        return output( $heap, "That doesn't look like a JID to me!" );
    }
    
    $user->server_jid( $server_jid );
    $user->current_command( 'new_table' );
    if ( $user->js and $user->manual_ui_load ) {
        output( $heap, "UI file manually loaded, so I won't fetch another over the network." );
        output( $heap, "To force a fetch, use the clear_ui command, then rejoin this table." );
        $user->request_new_table( $server_jid );
    } else {
        output( $heap, "Requesting UI file from the Volity network." );
        $user->manual_ui_load( undef );
        $user->request_disco_info({ to=>$server_jid, id=>"server" });
    }
}

sub cmd_add_bot {
    my $user = $_[HEAP]->{'default_player'};
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        to         => $user->referee_jid,
        id         => $rpc_id,
        methodname => 'volity.add_bot',
        handler    => 'add_bot',
        });
}

sub cmd_join_table {
  my( $heap, $table_jid ) = @_[ HEAP, &ARGS ];
  my $user = $heap->{'default_player'};
  return unless check_jid( $heap, $table_jid );
  if ( $user->js and $user->manual_ui_load ) {
      output( $heap, "UI file manually loaded, so I won't fetch another over the network.");
      output( $heap, "To force a fetch, use the clear_ui command, then rejoin this table.");
      $user->join_table($table_jid);
  } else {
      output( $heap,"You must load a UI file (with the load_ui command) before joining a table.");
      output( $heap,"(Friv does not yet support automatic UI fetching outside of table creation.)");
  }
}

sub cmd_tmsg {
    my( $heap, @message ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $message = join(' ', @message);
    unless ( defined $user->table_jid ) {
        return output( $heap,"Can't send a message to the table, since you're not at a table right now.");
    }
    unless ( defined $message ) {
        return output( $heap,"Beg your pardon? (Usage: tmsg [message-text])");
    }
    $user->send_message({
        type => 'groupchat',
        body => $message,
        to   => $user->table_jid,
        });
}

sub cmd_msg {
    my( $heap, $to, @message ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $message = join(' ', @message);
    unless ( defined $message ) {
        return output( $heap,"Beg your pardon? (Usage: msg [to-jid] [message-text])");
    }
    return unless check_jid($_[HEAP], $to);
    $user->send_message({
        type => 'normal',
        body => $message,
        to   => $to,
        });
}

sub cmd_start_game {
    my( $heap ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    unless ( defined $user->table_jid ) {
      return output( $heap,"Can't start a new game, because you're not seated at a table.");
    }
    my $rpc_id = ++$next_rpc_request_id;
    $user->make_rpc_request({
        id         => $rpc_id,
        to         => $user->referee_jid,
        methodname => 'volity.start_game',
        handler    => 'start_game',
        });
}

sub cmd_rmsg {
    my( $heap, @message ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $message = join(' ', @message);
    unless (defined($user->referee_jid)) {
        return output( $heap,"Can't send a message to the referee, since you're not at a table right now.");
    }
    unless (defined($message)) {
        return output( $heap,"Beg your pardon? (Usage: rmsg [message-text])");
    }
    $user->send_message({
        type => 'normal',
        body => $message,
        to   => $user->referee_jid,
        });
}

sub cmd_roster {
    my( $heap ) = @_[ HEAP, &ARGS ];
    my $user = $heap->{'default_player'};
    my $roster = $user->roster;
    my @jids = sort( $roster->jids );
    my @available_jids;
    my @unavailable_jids;
    for my $jid ( @jids ) {
        my @presence_list = $roster->presence( $jid );
        if ( @presence_list and grep { not defined $$_{type} or $$_{type} ne 'unavailable'} @presence_list ) {
            push @available_jids, $jid;
        } else {
            push @unavailable_jids, $jid;
        }
    }
    output( $heap, "----AVAILABLE----" );
    if ( @available_jids ) {
        for my $jid ( @available_jids ) {
#          output( $heap,$_);
          for my $presence ( $roster->presence( $jid ) ) {
            my $full_jid = $jid;
            if ( defined $$presence{'resource'} ) {
                $full_jid .= "/$$presence{resource}";
            }
            output( $heap, $full_jid );
          }
        }
    } else {
        output( $heap,"Nobody in your roster is online.");
    }
    if ( @unavailable_jids ) {
        output( $heap, "----UNAVAILABLE----" );
        foreach ( @unavailable_jids ) {
            output( $heap,$_);
        }
    }
}

package Volity::User;

use warnings;
use strict;

use base qw(Volity::Jabber);
use fields qw(nick output poe_heap table_jid referee_jid server_jid js opponents available_uis current_ui_url bookkeeper_jid uis_to_check current_command manual_ui_load);
use POE;

sub init_finish {
  my $self = $_[OBJECT];
  
  my $jid = $_[ARG0];
  
  # Succesful login!
  $self->print_message("Connection successful. Weclome to Volity.");
  $self->request_roster;
  $self->current_ui_url({});
}

sub receive_roster {
  my $self = shift;
  $self->SUPER::receive_roster(@_);
  # Having built our roster, we'll now announce our presence to the server.
  $self->send_presence;
}

sub print_message {
  my $self = shift;
  my ($message) = @_;
  &{ $self->output }( $self, $message );
}

sub rpc_response_new_table {
  my $self = shift;
  my( $message ) = @_;
  my $table_jid = $$message{'response'};
  $self->join_table($table_jid);

  my ($ref_resource) = $table_jid =~ /^(.*?)@/;
  my $ref_jid = $$message{'from'};
  $self->print_message("New table made, and joined. (Table JID: $table_jid)");
}

sub _rpc_receive_invitation {
    my $self = shift;
    my ($sender_jid, $invitation) = @_;
    $self->print_message("$sender_jid has invited you to a game!");
    if ($invitation->{message}) {
       $self->print_message("This message was attached:");
       $self->print_message($invitation->{message});
    }
    $self->print_message("Use the 'accept' command to accept the invitation.");
    $self->invitation($invitation);
    return 1;
}


sub fetch_ui_file {
    my $self = shift;
    my ($url) = @_;

    my $agent = LWP::UserAgent->new;

    # Now, at this point, we can do sexy things, like look at what we already
    # might have cached from previous forays to this URL.
    # Today, no sexiness. We will grab the URI file blindly and crush
    # whatever we last downloaded with the same name.
    # Sexiness tomorrow, maybe.
    my $request = HTTP::Request->new(GET=>$url);
    my $response = $agent->request($request);
    my $local_zipfile = File::Spec->catfile($working_dir, "ui.zip");
    open (ZIP, ">$local_zipfile") or die "Can't write ui zipfile $local_zipfile: $!\n";
    print ZIP $response->content;
    close (ZIP) or die "Can't close zipfile $local_zipfile: $!\n";
    my $zip_reader;
    unless ($zip_reader = Archive::Zip->new($local_zipfile)) {
        $self->print_message("Oh, there was a problem reading the zipfile $local_zipfile. Sorry.");
        return;
    }
    my $js_fh;
    my @js_source;
    if ($js_fh = Archive::Zip::MemberRead->new($zip_reader, "main")) {
        while (defined(my $line = $js_fh->getline)) { 
            push (@js_source, $line);
        }
    } else {
        $self->print_message("The archive $local_zipfile doesn't seem to have a main file. I can't use it. Sorry...");
        return;
    }
    
    # Having done all that, create the JS interpreter.
    
    $self->load_js_from_source(join("\n", @js_source));

    # Now make the actual RPC request.

    if ($self->current_command eq 'new_table') {
        $self->request_new_table($self->server_jid);
    } elsif ($self->current_command eq 'accept_invitation') {
        $self->join_table($self->invitation->{table});
    }

}

sub request_new_table {
    my $self = shift;
    my ($server_jid) = @_;
    my $rpc_id = 'new-table';
    $self->make_rpc_request(
                            {
                                to=>$self->server_jid,
                                id=>$rpc_id,
                                methodname=>'volity.new_table',
                                handler=>'new_table',
                            }
                            );
}

sub join_table {
    my $self = shift;
    my ($table_jid) = @_;
    $self->clear_opponent_nicknames;
    $self->join_muc(
                  {
                   jid=>$table_jid,
                   nick=>$self->nick || $self->user,
                  }
                 );
  $self->table_jid($table_jid);
}

sub load_js_from_source {
    my $self = shift;
    my ($js_source) = @_;
    my $commands = $self->poe_heap->{commands} ||= [];

    my $js = JavaScript::SpiderMonkey->new();
    $js->init();
    my $game = $js->object_by_path("game");
    my $referee = $js->object_by_path("client");
    my $info = $js->object_by_path("info");
    $js->function_set("writeln", sub { main::js_writeln( $self->terminal, @_) } );
    $js->function_set("rpc", sub { main::js_rpc( $self, @_ ) } );
    $js->function_set("registerCommand", 
                      sub { main::js_registerCommand( $commands, @_ ) } , $referee );
    
    $js->eval( $js_source );

    $js->eval( "info.nickname = '" . ($self->nick || $self->user) . "'" );
    $js->eval( "info.opponents = {}" );
    for my $nickname ($self->opponent_nicknames) {
        $js->eval( "info.opponents['$nickname'] = {}" );
    }
    
    if ($self->js) {
        $self->js->destroy;
    }
    $self->js( $js );
}

sub rpc_response_add_bot {
  my $self = shift;
  my( $message ) = @_;
  $self->print_message("Response from the bot-add request was: $$message{'response'}");
}

sub rpc_response_invite_player {
    my $self = shift;
    $self->print_message("The invitation has been sent.");
}

sub rpc_response_start_game {
  my $self = shift;  
  $self->print_message("The game has begun. Good luck!");
}

sub rpc_response_default {
  my $self = shift;
  my ($message) = @_;
  $self->print_message("Received an RPC response with id ".
    "$$message{'id'}, but I don't know how to handle it.");
}

sub handle_rpc_transmission_error {
  my $self = shift;
  my ($iq, $code, $error_message) = @_;
  my $full_message = "Failed to send an RPC packet. Error: $code";
  if (defined($error_message)) {
    $full_message .= " - $error_message";
  }
  $self->print_message($full_message);
}

sub handle_rpc_fault {
  my $self = shift;
  my ($fault_hash) = @_;
  my $full_message = "Received an RPC fault response: ";
  $full_message .= join(' - ', $$fault_hash{fault_code}, $$fault_hash{fault_string});
  $self->print_message($full_message);
}

sub handle_rpc_request {
  my $self = shift;
  my ($req) = @_;
  my $sub;
  if ($$req{method} =~ /^volity\.(\w+)/) {
      my $rpc_method = $1;
      my $local_method = "_rpc_$rpc_method";
      my $return_value;
      if ($self->can($local_method)) {
          my @return_values = $self->$local_method($$req{from}, @{$$req{args}});
          if (@return_values < 2) {
              $self->send_rpc_response($$req{from}, $$req{id}, @return_values);
          } else {
              $self->send_rpc_fault($$req{from}, $$req{id}, @return_values);
          }
      } else {
          $self->warn("Got bogus RPC request, '$$req{method}'");
      }
  } elsif ($$req{'method'} =~ /^game\.(\w+)/) {
# XXX
      main::js_call( $self->js, $$req{'method'}, @{ $$req{'args'} } );
  } else {
      $self->print_message("Unknown rpc request namespace: $$req{'method'}");
  }
}

sub handle_normal_message {
  my $self = shift;
  my ($message) = @_;
  $self->print_message("From: $$message{from}");
  $self->print_message("$$message{body}");
}

sub handle_chat_message {
  my $self = shift;
  my ($message) = @_;
  $self->print_message("From: $$message{from}");
  $self->print_message("$$message{body}");
}

sub handle_groupchat_message {
  my $self = shift;
  my ($message) = @_;
  my ($sender_nickname) = $$message{from} =~ /\/(.*)$/;
  $sender_nickname ||= $$message{from};
  $$message{body} ||= '';
  $self->print_message("$sender_nickname: $$message{body}");
}

# This presence handler detects a table's referee through MUC attributes.
# It also watches for general presence updates, and updates the user's
# internal roster object as needed.
sub jabber_presence {
  my $self = shift;
  my ($node) = @_;
  my $x; # Hey, that's the name of the element, OK?
  if (defined($node->attr('type')) and $node->attr('type') eq 'error') {
    # Ruh roh. Just print an error message.
    my $error = $node->get_tag('error');
    my $code = $error->attr('code');
    $self->print_message("Got an error ($code):");
    my $message = $error->data || "Something went wrong.";
    $self->print_message($message);
    return;
  }
  if (($node->get_tag('x')) and (($x) = grep($_->attr('xmlns') eq "http://jabber.org/protocol/muc#user", $node->get_tag('x')))) {
    # Aha, someone has joined the table.
    my $new_person_jid = $x->get_tag('item')->attr('jid');
    my $affiliation = $x->get_tag('item')->attr('affiliation');
    if ($affiliation eq 'owner') {
      # This is the table's ref.
      $self->referee_jid($new_person_jid);
    } else {
      # This is a potential opponent!
      unless ($node->attr('type')) {
        # No 'type' attribute means they're joining us...
        # Save the nickname. We'll pass it to the UI file later.
        $self->add_opponent_nickname($node->attr('from'));
      } elsif ($node->attr('type') eq 'unavailable') {
        # Oh, they're leaving...
        $self->remove_opponent_nickname($node->attr('from'));
      }
    }
  } elsif ($self->roster->has_jid( $node->attr('from') )) {
    # Someone on our roster just changed their presence.
    my $roster = $self->roster;
    my $jid = $node->attr('from');
    my $presence_hash = {type=>$node->attr('type')};
    foreach (qw(show status priority)) {
      $$presence_hash{$_} = $node->get_tag($_)->data if $node->get_tag($_);
    }
    $roster->presence($jid, $presence_hash);
    my $prez = $roster->presence($jid);
  }
}

sub handle_disco_info {
    my $self = shift;
    my ($from, $id, $items, $fields) = @_;
    my @items = @$items;

    # The value of $id indicates what sort of Volity entity sent the packet.
    if ($id =~ /^ruleset-ui(\d+)$/) {
        my $id_number = $1;
        my $current_ui_url = $self->current_ui_url->{$id_number};
        my @types = @{$$fields{"client-type"}};
        if (grep($_ eq 'http://volity.org/protocol/ui/text', @types)) {
            # Good, this one is available to us.
            push (@{$self->{available_uis}},
                  {
                      url=>$current_ui_url,
                      description=>$$fields{description}->[0],
                      reputation=>$$fields{reputation}->[0],
                  },
                  );
        }
        $self->{uis_to_check} -= 1;
        unless ($self->uis_to_check) {
            if (@{$self->available_uis} > 1) {
#                use Data::Dumper; die Dumper($self->available_uis);
                $self->show_ui_menu;
            } elsif (@{$self->available_uis}) {
                my $ui = $self->available_uis->[0];
#                use Data::Dumper; die (Dumper($ui));
                $self->print_message("Fetching game UI file from $$ui{url}...");
                $self->fetch_ui_file($$ui{url});
            } else {
                $self->print_message("No text UIs available for this game. Sorry.");
            }
        }

    } elsif ($id eq 'server') {
        my ($ruleset_uri) = @{$$fields{ruleset}};
        my ($ruleset_version) = @{$$fields{"ruleset-version"}};

        $self->discover_uis_for_ruleset($ruleset_uri);
    } else {
        $self->print_message("Um... I got a disco info response with id $id. I'm not sure what to do about it.");
    }
}

# discover_uis_for_ruleset: make a disco request for a given ruleset's
# ui-items.
# WARNING! The way this is presently coded, this plugs into a chain reaction
# that will end up in a UI being downloaded. Well... so be it.
sub discover_uis_for_ruleset {
    my $self = shift;
    my ($ruleset_uri) = @_;
    
    $self->request_disco_items({to=>$self->bookkeeper_jid,
                                id=>'ruleset',
                                node=>$ruleset_uri . "|uis",
                            });
}

sub handle_disco_items {
    my $self = shift;
    my ($from, $id, $items) = @_;
    my @items = @$items;
    
    if ($id eq 'ruleset') {
        $self->available_uis([]);
        $self->uis_to_check(scalar(@items));
        my $id_num = 0;
        for my $item (@items) {
            my $iq_id = "ruleset-ui" . ++$id_num;
            $self->current_ui_url->{$id_num} = $item->node;
            $self->request_disco_info({to=>$item->jid, 
                                  id=>$iq_id,
                                  node=>$item->node,
                              });
        }
    }
}

# add_opponent_nickname: Add the given nickname (either a full JID in MUC
# format, or a bare string containing only the nickname) to our internal
# list of known opponents at the current table.
sub add_opponent_nickname {
  my $self = shift;
  my ($name) = @_;
  my $nickname;
  if (main::is_jid($name)) {
    ($nickname) = $name =~ /\/(.*)$/;
    unless ($nickname) {
      die "GACK. I couldn't tease a nickname out of the jid $name.";
    }
  } else {
    $nickname = $name;
  }
  my $my_nickname = $self->nick || $self->user;
  unless ($my_nickname eq $nickname) {
    $self->{opponents}{$nickname} = 1;
  }
}

sub remove_opponent_nickname {
  my $self = shift;
  my ($name) = @_;
  my $nickname;
  if (main::is_jid($name)) {
    ($nickname) = $name =~ /\/(.*)$/;
    unless ($nickname) {
      die "GACK. I couldn't tease a nickname out of the jid $name.";
    }
  } else {
    $nickname = $name;
  }
  return(delete($self->{opponents}{$nickname}));
}

sub opponent_nicknames {
  my $self = shift;
  return keys(%{$self->{opponents}});
}

sub clear_opponent_nicknames {
  my $self = shift;
  $self->{opponents} = {};
}

=head1 NAME

Friv - A simple text-only Volity client

=head1 SYNOPSIS

 $ friv -u myusername -p mypassword -h volity.net

 Connection successful. Weclome to Volity.
 Volity> new_table rps@volity.net/testing   
 Requesting UI file from the Volity network.
 Fetching game UI file from http://volity.org/games/rps/text/rps.zip...
 rps.js Loaded!
 New table made, and joined.
 Volity> add_bot
 Response from the bot-add request was: ok
 Volity> start_game
 The game has begun. Good luck!
 RPS begins!  Have fun and good luck!
 RandomBot: I have made my move.
 Volity> select rock
 Good old rock! Nothing beats rock.

 [etc....]

=head1 DESCRIPTION

This program provides a very simple text-based interface to the Volity
network. It will let you create or join tables at any game server, so
long as a text-based UI file for that server's game is available.

Friv is part of I<Frivolity>, the Perl implementation of the Volity
network game platform. While it aims to be a full-featured Volity
client, it is more geared towards testing and hacking than general
use. For a more user-friendly Volity experience, we recommend a
GUI-based client, such as Javolin.

To learn more about Volity, visit the Volity developers' webesite at
http://volity.org.

=head1 USAGE

To play a game, use the C<new_table> command (see L<"COMMANDS">) to
create a new Volity table. You can then call C<add_bot> to summon
automated players (if the server supports them), or have your friends
join through their own clients. (Friv does not support any sort of
invitation mechanism yet.)  When you are ready to start playing, call
C<start_game>.

Like all Volity clients, Friv requires an appropriate set of
user-interface files before you can play a game. When you request a
new table, Friv will automatically negotiate with the specified server
in an attempt to locate a text-friendly UI file to download and
use. If successful, it transparently sets up everything it needs and
escorts you to the new table. Otherwise, you'll receive an apologetic
message.

After joining a table, use the C<help> command to see both a summary
of Friv's global commands I<and> the commands specific to the game UI
currently laoded. For example, the "select" command shown in
L<"SYNOPSIS"> was defined by the rock-paper-scissors UI file that Friv
transparently loaded when that user created a table at a
rock-paper-scissors game server.

You can also use the C<join_table> command to join a game table that
someone else has already created. Unfortunately, Friv currently lacks
the ability to fetch UI files when joining tables in this fashion; you
will have to have your own local copy of that file, and C<load_ui> on
it before joining.

=head1 RUNNING

Friv takes the following flags on launch:

=head2 Required flags

These flags set information that Friv needs to authenticate you with a
Volity (Jabber) server.

If you don't supply these as command flags, the program will prompt
you for them. (Supplying your password in this way offers more
security than supplying it on the command line.)

=over

=item u

The account's username.

=item h

The account's host. Examples: volity.net, jabber.org.

=item p

The account's password.

=back

=head2 Optional flags

=over

=item b

The Volity bookkeeper JID to use. Defaults to
bookkeeper@volity.net. Unless you really know what you're doing, you
probably shouldn't change this.

=item f

The working directory that Friv can use to store its scratch
files. Defaults to "$ENV{HOME}/.friv".

=item o

The TCP port to connect to. Defaults to 5222 (Jabber's default port).

=item r

The resource to use with the Jabber account. Defaults to 'friv'.

=back

=head1 COMMANDS

=over

=item roster

View your Jabber roster, including indicators of who's online and who's not.

=item help

Displays a list of the standard Friv commands (as described in this
manpage), as well as any game-specific commands defined by the current UI
file (if there is one).

=item load_ui C<filename>

Loads an ECMAScript UI file from the local filesystem. Useful if
you're testing a new UI file, or otherwise have a file that isn't
available over the network. If you load a UI file manually,
C<new_table> won't attempt to fetch a replacement over the network
unless you C<clear_ui> first.

Once you load a UI file, several new game-specific commands may
before available. Use the C<help> command to see a list of them (along
with all the other standard Friv commands).

=item clear_ui

Clears the currently loaded UI file from memory.

=item new_table C<JID>

Attempt to create a new table at the specified JID. If successful, you
will immediately join the new table.

If you have not manually loaded a UI file (with C<load_ui>), Friv will
open negotiation with the specified server in order to find and load
an appropriate UI file by itself. It it cannot do so, you'll recieve
an explanatory error message, and no table will be created.

=item join_table C<JID>

Attempt to join the table (or Jabber groupchat) at the specifed JID.

Unfortunately, you must load a UI file manually (with C<load_ui>)
before calling this. Future versions of Friv will be able to fetch the
appropriate UI file over the network, much as with C<new_table>.

=item add_bot

Summon a bot to the current table. Only works if the referee offers a
single bot type. (Friv currently lacks the form-support needed to
choose new bots.)

=item invite C<JID>

Sends an invitation to the player with the given jid. Only works if you are already seated at a table.

=item accept

Accepts the last invitation you received, and brings you to the table.

=item start_game

Request that the referee at the current table start the game.

=item msg C<JID> C<Message body>

Send the given text (as a 'normal'-type Jabber message) to the specifed JID.

=item tmsg C<Message body>

Send the given text (as a 'groupchat'-type Jabber message) to the table.

=item rmsg C<Message body>

Send the given text to the table's referee.

=item quit

Quits the program (and logs you out of the system).

=back

=head1 BUGS

The most recent version of Friv represents the most advanced state of
the Volity platform. Since Volity is unfinished, so is Friv, and it
just about the same ways. On the other hand, Friv will continue to
develop so long as Volity does. Stay tuned.

=head1 AUTHOR

Jason McIntosh <jmac@jmac.org> (Jabber: jmac@volity.net)

=head1 COPYRIGHT

Copyright (c) 2004 by Jason McIntosh

=head1 SEE ALSO

L<Volity>

http://volity.org

=cut
