#!/usr/local/bin/perl

=begin TODO

* Fix history browsing so that the cursor snaps back to the end when ya done.

=end TODO

=cut

use warnings;
use strict;

use POE;
use POE::Wheel::ReadLine;
use JavaScript::SpiderMonkey;
use Data::JavaScript::Anon;
use Getopt::Std;
use YAML;

my %opts;
getopts('u:h:p:r:o:d:', \%opts);

foreach (qw( user host password )) {
    my $letter = substr( $_, 0, 1 );
    unless (defined $opts{$letter}) {
        my $answer = '';
        until ( $answer ) {
            print "$_: ";
            chomp( $answer = <STDIN> );
        }
        $opts{ $letter } = $answer;
    }
}

################
# GLOBALS
################
our @cmd_hist = eval { @{ YAML::LoadFile("client.yaml") } };
my $next_rpc_request_id = 0;
my $last_message_recipient;

POE::Session->create(
                     inline_states => {
                                       _start => \&start,
                                       user_input => \&user_input,
                                      }
                    );

POE::Kernel->run;

sub start {
    my($session,$heap) = @_[SESSION,HEAP];
    $heap->{'user'} = POE::Wheel::ReadLine->new(
        InputEvent => 'user_input',
        PutMode => 'immediate',
        );
    foreach (@cmd_hist) {
        $heap->{'user'}->addhistory($_);
    }
    $heap->{'user'}->get( 'Volity> ' );
    $heap->{username} = $opts{u};
    $heap->{resource} = $opts{r} || 'friv';
    $heap->{port} = $opts{o} || 5222;
    $heap->{host} = $opts{h};
    my $user = Volity::User->new(
                                 {
                                  host=>$heap->{host},
                                  password=>$opts{p},
                                  resource=>$heap->{resource},
                                  port=>$heap->{port},
                                  alias=>$heap->{resource},
                                  debug=>$opts{d} || 0,
                                  user=>$heap->{username},
                                 }
                                );
    $heap->{user_obj} = $user;
    $user->terminal($heap->{user});
    $user->kernel->run;
}

sub is_jid {
  my ($jid) = @_;
  if ($jid =~ /^\w+@\w+(?:\.\w+)*(?:\/\w+)?/) {
    return $jid;
  } else {
    return;
  }
}

sub check_jid {
  my ($pipe, $jid) = @_;
  if (is_jid($jid)) {
    return $jid;
  } else {
    $pipe->put("The string '$jid' doesn't look like a JabberID to me!");
    $pipe->put("Command ignored.");
    return;
  }
}

END {
    YAML::DumpFile("client.yaml",\@cmd_hist);
}

######################
# Input hanlding
######################

sub user_input {
    my($heap,$input,$exception) = @_[HEAP, ARG0, ARG1];
    my $user = $heap->{user_obj};
    if (defined $input) {
        $heap->{'user'}->get('Volity> ');
        my($cmd,@args) = tokenize($input,{});
        $cmd = lc( $cmd );

        return if not(defined($cmd)) or $cmd eq '';

        $heap->{'user'}->addhistory($input);
        push(@cmd_hist,$input);

        if (my $sub = __PACKAGE__->can("cmd_$cmd")) {
            &$sub(@_[0..(ARG0-1)],@args);
            return;
        }
        if ($heap->{'commands'}) {
           foreach (@{ $heap->{'commands'} }) {
               if ( $$_[0] eq $cmd ) {
                   js_call( $user->js, "client.$cmd", @args );
                   return;
               }
           }
        }
        $heap->{'user'}->put("Unknown command: $input");
    } else {
        $heap->{'user'}->put("Exception: $exception");
        exit;
    }
}

sub js_call {
    my( $js, $cmd, @args ) = @_;
    my $script = "$cmd(";
    foreach (@args) {
        next if /^-?\d*(?:\.\d+)?$/;
	next if ref($_);
        s/'/\\'/g;
        $_ = "'$_'";
    }
    # Convert the @args into a list of JS-safe strings.
    my @js_args;
    for my $arg (@args) {
	if (ref($arg)) {
	    push (@js_args, Data::JavaScript::Anon->anon_dump($arg));
	} else {
	    push (@js_args, $arg);
	}
    }
    $script .= join ', ', @js_args;
    $script .= ")";
    return $js->eval( $script );
}

sub tokenize {
    my($str,$vars) = @_;
    my @tokens;
    my $tok_count = 0;
    my $last = 0;
    while ($str =~ /\G(?:"([^"]+)(?<!\\)"|'([^']+)(?<!\\)'|((?:[^\s"']|(?<=\\)'|(?<=\\)"|(?<=\\)\s)+)|((?:(?<!\\)\s)+))/g) {
        $last = pos($str);
        my($dq,$sq,$nq,$sp) = ($1,$2,$3,$4);
        my $val = $dq||$sq||$nq||$sp;
        if ($dq or $nq) {
            $val = expand($val,$vars);
        } else {
            $val = unescape($val);
        }
        if ($sp) {
            $tok_count ++ if $#tokens == $tok_count;
        } else {
            $tokens[$tok_count] .= $val;
        }
    }
    if ($last < length($str)) {
        $tokens[$tok_count] .= substr($str,$last);
    }
    return @tokens;
}

sub unescape {
    my($str) = @_;
    $str =~ s/\\(.)/$1/g;
    return $str;
}

sub expand {
    my($str,$vars) = @_;
    $str =~ s{
            (?:
            (?<!\\)\$(\w+) |
            \\(.)
            )
        }{
            if ($1) {
                $$vars{$1};
            } else {
                $2
            }
        }gxe;
    $str = unescape($str);
    return $str;
}

###########################
# User commands
###########################

sub cmd_info {
    my($heap) = $_[HEAP];
    no warnings qw(uninitialized);
    my $user = $heap->{user_obj};
    $heap->{'user'}->put($_) for
      "Status information:",
      "  JID: ".$user->jid,
      "  Nickname: ".$user->nick,
      "  Table JID: ".$user->table_jid,
      "  Referee JID: ".$user->referee_jid;
}

sub cmd_quit {
    my($heap) = $_[HEAP];
    $heap->{'user'}->put('Be seeing you.');
    $heap->{user_obj}->send_presence({type=>'unavailable'});
    exit;
}

sub cmd_nick {
    my($heap,$nickname) = @_[HEAP,ARG0..$#_];
    unless ($nickname) {
        $heap->{'user'}->put("Form: nick <nickname>");
        return;
    }
    $heap->{'nick'} = $nickname;
    $heap->{user_obj}->nick($nickname);
    $heap->{'user'}->put("Nickname set.");
}

sub cmd_debug {
  my ($heap) = $_[HEAP];
  my $user = $heap->{user_obj};
  $heap->{user}->put("Current user object: $user");
}

sub cmd_help {
  my($heap,$on) = @_[HEAP,ARG0..$#_];
  $heap->{'user'}->put("$_") for split /\n/, <<CMDLIST;
Volity client commands:
  msg (JID) (text) - send private message to the given JID
  tmsg (text)      - send groupchat message to the current table
  rmsg (text)      - send private message to the current referee

  nick (nickname)  - set a new table nickname for yourself
  roster           - view your roster


  new_table (JID)  - request a new table from the given server JID
  join_table (JID) - join an existing table
  load_ui (file)   - load a ui control file (do this before starting a game)
  add_bot          - request a new bot for the current table
  start_game       - request a new game at the current table

  info             - see some info about your current status
  help             - this list
  quit             - log off from Volity and exit this program
CMDLIST
  return unless $heap->{'commands'};
  $heap->{'user'}->put( "" );
  foreach (@{ $heap->{'commands'} }) {
    $heap->{'user'}->put( sprintf("  %-16s - %s",$$_[0],$$_[1]) );
  }
}

sub cmd_load_ui {
  my ($heap, $filename) = @_[HEAP, ARG0];

  my $term = $heap->{'user'};
  
  unless (open FILE, $filename) {
      $term->put("Couldn't open $filename: $!");
      return;
  }
  my $source = join '', <FILE>;
  close FILE;
  
  my $user = $heap->{'user_obj'};
  my $commands = $heap->{'commands'} ||= [];
  my $js = JavaScript::SpiderMonkey->new();
  $js->init();
  my $game = $js->object_by_path("game");
  my $referee = $js->object_by_path("client");
  my $info = $js->object_by_path("info");
  $js->function_set("writeln", sub { js_writeln( $term, @_) } );
  $js->function_set("rpc", sub { js_rpc( $user, @_ ) } );
  $js->function_set("registerCommand", 
    sub { js_registerCommand( $commands, @_ ) } , $referee );

  $js->eval( $source );

  $js->eval( "info.nickname = '" . ($user->nick || $user->user) . "'" );
  $js->eval( "info.opponents = {}" );
  for my $nickname ($user->opponent_nicknames) {
    $js->eval( "info.opponents['$nickname'] = {}" );
  }
  
  if ($user->js) {
      $user->js->destroy;
  }
  $user->js( $js );
}

sub js_writeln {
    my ($term, @output) = @_;
    $term->put( "@output" );
}

sub js_rpc {
    my ($user, $cmd, @args) = @_;
    
#    warn "Da command is: $cmd\n";
#    warn "Da args are: @args\n";

# XXX
#    $user->print_message( "Making RPC call to $cmd..." );
    $user->make_rpc_request(
                            {
                             to=>$user->referee_jid,
                             id=>"$cmd.".time,
                             methodname=>"game.$cmd",
			     args=>\@args,
                             handler=>sub {},
                            }
                           );
}

sub js_registerCommand {
    my( $commands, $command, $shortdesc, $longdesc ) = @_;
    push @$commands, [ $command, $shortdesc, $longdesc ];
}

sub cmd_new_table {
  my ($heap, $server_jid) = @_[HEAP, ARG0];
  my $user = $heap->{user_obj};
  unless (defined($server_jid)) {
    $heap->{user}->put("Usage: new_table [game-server-jid]");
    return;
  }
  unless (is_jid($server_jid)) {
    $heap->{user}->put("That doesn't look like a JID to me!");
    return;
  }
  unless ($user->js) {
      $user->print_message("Load a UI file before starting a new table.");
      return;
  }
  my $rpc_id = ++$next_rpc_request_id;
  $user->make_rpc_request(
                          {
                           to=>$server_jid,
                           id=>$rpc_id,
                           methodname=>'volity.new_table',
                           handler=>'new_table',
                          }
                         );
}

sub cmd_add_bot {
  my $user = $_[HEAP]->{user_obj};
  my $rpc_id = ++$next_rpc_request_id;
  $user->make_rpc_request(
                          {
                           to=>$user->referee_jid,
                           id=>$rpc_id,
                           methodname=>'volity.add_bot',
                           handler=>'add_bot',
                          }
                         );
}

sub cmd_join_table {
  my $user = $_[HEAP]->{user_obj};
  my $table_jid = $_[ARG0];
  return unless check_jid($_[HEAP]->{user}, $table_jid);
  unless ($user->js) {
      $user->print_message("Load a UI file before joining a table.");
      return;
  }
  $user->clear_opponent_nicknames;
  $user->join_muc(
                  {
                   jid=>$table_jid,
                   nick=>$user->nick || $user->user,
                  }
                 );
  # Tell the user that it's now seated at a table.
  $user->table_jid($table_jid);
#  $user->referee_jid("$table_jid/volity");
}

sub cmd_tmsg {
  my ($user, @message) = ($_[HEAP]->{user_obj}, @_[ARG0..$#_]);
  my $message = join(' ', @message);
  unless (defined($user->table_jid)) {
    $user->print_message("Can't send a message to the table, since you're not at a table right now.");
    return;
  }
  unless (defined($message)) {
    $user->print_message("Beg your pardon? (Usage: tmsg [message-text])");
    return;
  }
  $user->send_message(
                      {
                       type=>'groupchat',
                       body=>$message,
                       to=>$user->table_jid,
                      }
                     );
}

sub cmd_msg {
  my ($user, $to, @message) = ($_[HEAP]->{user_obj}, $_[ARG0], @_[ARG1..$#_]);
  my $message = join(' ', @message);
  unless (defined($message)) {
    $user->print_message("Beg your pardon? (Usage: msg [to-jid] [message-text])");
    return;
  }
  return unless check_jid($user->terminal, $to);
  $user->send_message(
                      {
                       type=>'normal',
                       body=>$message,
                       to=>$to,
                      }
                     );
}

sub cmd_start_game {
  my $user = $_[HEAP]->{user_obj};
  unless (defined($user->table_jid)) {
    $user->print_message("Can't start a new game, because you're not seated at a table.");
    return;
  }
  my $rpc_id = ++$next_rpc_request_id;
  $user->make_rpc_request(
                          {
                           id=>$rpc_id,
                           to=>$user->referee_jid,
                           methodname=>'volity.start_game',
                           handler=>'start_game',
                          }
                         );
}

sub cmd_rmsg {
  my ($user, @message) = ($_[HEAP]->{user_obj}, @_[ARG0..$#_]);
  my $message = join(' ', @message);
  unless (defined($user->referee_jid)) {
    $user->print_message("Can't send a message to the referee, since you're not at a table right now.");
    return;
  }
  unless (defined($message)) {
    $user->print_message("Beg your pardon? (Usage: rmsg [message-text])");
    return;
  }
  $user->send_message(
                      {
                       type=>'normal',
                       body=>$message,
                       to=>$user->referee_jid,
                      }
                     );
}

sub cmd_roster {
  my $user = $_[HEAP]->{user_obj};
  my $roster = $user->roster;
  my @jids = sort($roster->jids);
  my @available_jids; my @unavailable_jids;
  for my $jid (@jids) {
    my @presence_list = $roster->presence($jid);
    if (@presence_list and grep(((not(defined($$_{type}))) or ($$_{type} ne 'unavailable')), @presence_list)) {
      push (@available_jids, $jid);
    } else {
      push (@unavailable_jids, $jid);
    }
  }
  $user->print_message("----AVAILABLE----");
  if (@available_jids) {
    for my $jid (@available_jids) {
#      $user->print_message($_);
      for my $presence ($roster->presence($jid)) {
        my $full_jid = $jid;
        if (defined $$presence{'resource'}) {
            $full_jid .= "/$$presence{resource}";
        }
        $user->print_message( $full_jid );
      }
    }
  } else {
    $user->print_message("Nobody in your roster is online.");
  }
  if (@unavailable_jids) {
    $user->print_message("----UNAVAILABLE----");
    foreach (@unavailable_jids) {
      $user->print_message($_);
    }
  }
}

package Volity::User;

use warnings;
use strict;

use base qw(Volity::Jabber);
use fields qw(nick terminal table_jid referee_jid js opponents);
use POE;

sub jabber_authed {
  my $self = $_[OBJECT];
  my( $node ) = @_[ARG0..$#_];
  
  # Succesful login!
  if ( $node->attr('type') eq 'result') {
    $self->print_message("Connection successful. Weclome to Volity.");
    $self->request_roster;
  }
  # Failed login...
  elsif ( $node->attr('type') eq 'error') {
    my $details  = $node->get_children_hash;
    my $query    = $$details{'query'}->get_childbren_hash;
    my $username = $$query{'username'}->data;
    my $code     = $$details{'error'}->attr('code');
    my $desc     = $$details{'error'}->data;
    $self->print_message( "Login failed, username $username: $code $desc");
    print "\r        \r"; # Delete the prompt
    exit;
  }
  # Huh?
  else {
    $self->print_message( "Unknown response from auth request: ".$node->to_str );
  }
}

sub receive_roster {
  my $self = shift;
  $self->SUPER::receive_roster(@_);
  # Having built our roster, we'll now announce our presence to the server.
  $self->send_presence;
}

sub print_message {
  my $self = shift;
  my ($message) = @_;
  $self->terminal->put($message);
}

sub rpc_response_new_table {
  my $self = shift;
  my( $message ) = @_;
  my $table_jid = $$message{'response'};
  $self->clear_opponent_nicknames;
  $self->join_muc( {
    jid  => $table_jid,
    nick => $self->nick || $self->user,
    } );
  $self->table_jid($table_jid);
  my ($ref_resource) = $table_jid =~ /^(.*?)@/;
  my $ref_jid = $$message{'from'};
  $self->print_message("New table made, and joined. (Table JID: $table_jid)");
}

sub rpc_response_add_bot {
  my $self = shift;
  my( $message ) = @_;
  $self->print_message("Response from the bot-add request was: $$message{'response'}");
}

sub rpc_response_start_game {
  my $self = shift;  
  $self->print_message("The game has begun. Good luck!");
}

sub rpc_response_default {
  my $self = shift;
  my ($message) = @_;
  $self->print_message("Received an RPC response with id ".
    "$$message{'id'}, but I don't know how to handle it.");
}

sub handle_rpc_transmission_error {
  my $self = shift;
  my ($iq, $code, $error_message) = @_;
  my $full_message = "Failed to send an RPC packet. Error: $code";
  if (defined($error_message)) {
    $full_message .= " - $error_message";
  }
  $self->print_message($full_message);
}

sub handle_rpc_fault {
  my $self = shift;
  my ($fault_hash) = @_;
  my $full_message = "Received an RPC fault response: ";
  $full_message .= join(' - ', $$fault_hash{fault_code}, $$fault_hash{fault_string});
  $self->print_message($full_message);
}

sub handle_rpc_request {
  my $self = shift;
  my ($req) = @_;
  my $sub;
  unless ($$req{'method'} =~ /^game\.(\w+)/) {
      $self->print_message("Unknown rpc request namespace: $$req{'method'}");
  }
# XXX
  main::js_call( $self->js, $$req{'method'}, @{ $$req{'args'} } );
}

sub handle_normal_message {
  my $self = shift;
  my ($message) = @_;
  $self->terminal->put("From: $$message{from}");
  $self->terminal->put("$$message{body}");
}

sub handle_chat_message {
  my $self = shift;
  my ($message) = @_;
  $self->terminal->put("From: $$message{from}");
  $self->terminal->put("$$message{body}");
}

sub handle_groupchat_message {
  my $self = shift;
  my ($message) = @_;
  my ($sender_nickname) = $$message{from} =~ /\/(.*)$/;
  $sender_nickname ||= $$message{from};
  $$message{body} ||= '';
  $self->terminal->put("$sender_nickname: $$message{body}");
}

# This presence handler detects a table's referee through MUC attributes.
# It also watches for general presence updates, and updates the user's
# internal roster object as needed.
sub jabber_presence {
  my $self = shift;
  my ($node) = @_;
  my $x; # Hey, that's the name of the element, OK?
  if (defined($node->attr('type')) and $node->attr('type') eq 'error') {
    # Ruh roh. Just print an error message.
    my $error = $node->get_tag('error');
    my $code = $error->attr('code');
    $self->terminal->put("Got an error ($code):");
    my $message = $error->data || "Something went wrong.";
    $self->terminal->put($message);
    return;
  }
  if (($node->get_tag('x')) and (($x) = grep($_->attr('xmlns') eq "http://jabber.org/protocol/muc#user", $node->get_tag('x')))) {
    # Aha, someone has joined the table.
    my $new_person_jid = $x->get_tag('item')->attr('jid');
    my $affiliation = $x->get_tag('item')->attr('affiliation');
    if ($affiliation eq 'owner') {
      # This is the table's ref.
      $self->referee_jid($new_person_jid);
    } else {
      # This is a potential opponent!
      unless ($node->attr('type')) {
	# No 'type' attribute means they're joining us...
	# Save the nickname. We'll pass it to the UI file later.
	$self->add_opponent_nickname($node->attr('from'));
      } elsif ($node->attr('type') eq 'unavailable') {
	# Oh, they're leaving...
	$self->remove_opponent_nickname($node->attr('from'));
      }
    }
  } elsif ($self->roster->has_jid( $node->attr('from') )) {
    # Someone on our roster just changed their presence.
    my $roster = $self->roster;
    my $jid = $node->attr('from');
    my $presence_hash = {type=>$node->attr('type')};
    foreach (qw(show status priority)) {
      $$presence_hash{$_} = $node->get_tag($_)->data if $node->get_tag($_);
    }
    $roster->presence($jid, $presence_hash);
    my $prez = $roster->presence($jid);
  }
}

# add_opponent_nickname: Add the given nickname (either a full JID in MUC
# format, or a bare string containing only the nickname) to our internal
# list of known opponents at the current table.
sub add_opponent_nickname {
  my $self = shift;
  my ($name) = @_;
  my $nickname;
  if (main::is_jid($name)) {
    ($nickname) = $name =~ /\/(.*)$/;
    unless ($nickname) {
      die "GACK. I couldn't tease a nickname out of the jid $name.";
    }
  } else {
    $nickname = $name;
  }
  my $my_nickname = $self->nick || $self->user;
  unless ($my_nickname eq $nickname) {
    $self->{opponents}{$nickname} = 1;
  }
}

sub remove_opponent_nickname {
  my $self = shift;
  my ($name) = @_;
  my $nickname;
  if (main::is_jid($name)) {
    ($nickname) = $name =~ /\/(.*)$/;
    unless ($nickname) {
      die "GACK. I couldn't tease a nickname out of the jid $name.";
    }
  } else {
    $nickname = $name;
  }
  return(delete($self->{opponents}{$nickname}));
}

sub opponent_nicknames {
  my $self = shift;
  return keys(%{$self->{opponents}});
}

sub clear_opponent_nicknames {
  my $self = shift;
  $self->{opponents} = {};
}

=head1 NAME

Friv - A simple text-only Volity client

=head1 SYNOPSIS

$ friv -u myusername -p mypassword -h volity.net

=head1 DESCRIPTION

This program provides a very simple text-based interface to the Volity
network. It will let you play at any game server that provides a
text-only UI, over Jabber messaging (as opposed to SVG).

For more about Volity, visit http://volity.org

=head1 RUNNING

Friv takes the following flags on launch:

=head2 Required flags

These flags set information that Friv needs to authenticate you with a
Volity (Jabber) server.

If you don't supply these as command flags, the program will prompt
you for them. (Supplying your password in this way offers more
security than supplying it on the command line.)

=over

=item u

The account's username.

=item h

The account's host. Examples: volity.net, jabber.org.

=item p

The account's password.

=back

=head2 Optional flags

=over

=item r

The resource to use with the Jabber account. Defaults to 'friv'.

=item o

The TCP port to connect to. Defaults to 5222 (Jabber's default port).

=item d

Set to a true value to display verbose and perhaps largely meaningless debug messages. Defaults to 0.

=back

=head1 COMMANDS

=over

=item roster

View your Jabber roster, including indicators of who's online and who's not.

=item new_table C<JID>

Attempt to create a new table at the specified JID. If successful, you
will immediately join the new table.

=item join_table C<JID>

Attempt to join the table (or Jabber groupchat) at the specifed JID.

=item add_bot

Summon a bot to the current table. Only works if the referee offers a
single bot type. (Friv currently lacks the form-support needed to
choose new bots.)

=item start_game

Request that the referee at the current table start the game.

=item msg C<JID> C<Message body>

Send the given text (as a 'normal'-type Jabber message) to the specifed JID.

=item tmsg C<Message body>

Send the given text (as a 'groupchat'-type Jabber message) to the table.

=item rmsg C<Message body>

Send the given text to the table's referee.

=item quit

Quits the program (and logs you out of the system).

=back

=head1 AUTHOR

Jason McIntosh <jmac@jmac.org> (Jabber: jmac@volity.net)

=cut
